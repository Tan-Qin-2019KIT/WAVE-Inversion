%
%		LAMA_Implementation_Doc
%
\documentclass[pdftex,a4paper,parskip,listof=totoc,bibliography=totoc,onehalfspacing,12pt]{scrreprt}
\usepackage[english]{babel} % If german is needed add ngerman in first bracket 
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{textcomp}
\usepackage{multirow}
%\usepackage{graphicx} is loaded with pdfpages
\usepackage{pict2e}
\usepackage{multicol}
\usepackage[automark]{scrpage2}
\usepackage{setspace}
\usepackage{color}
\usepackage{natbib}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{mathtools}			%For use of \mathrlap and \mathllap
\usepackage{amsfonts}			%For use of \mathbb{R} (e.g., show real number letter)
\usepackage{float}
\usepackage{longtable}
\usepackage{pdfpages}
\usepackage{eso-pic}
\usepackage{dirtree}
\usepackage{multirow}
\usepackage{gauss}				% For use of \newcommand*\dashline... (vertical line in arrays)
\usepackage[vlined]{algorithm2e}
\usepackage{enumitem}
	\setlist[itemize]{itemsep=-12pt}
	\setlist[enumerate]{itemsep=-12pt}
\usepackage{subcaption}
\usepackage{lscape}		%For use of \begin{landscape} \end{landscape} Zur Darstellung einzelner Seiten im Querformat
\usepackage{adjustbox}
\usepackage{nicefrac}
\usepackage{physics}
\usepackage{verbatimbox}
\KOMAoptions{twoside}
\setcounter{MaxMatrixCols}{50}

\usepackage[left=25mm,right=25mm,bottom=35mm, footskip=20mm]{geometry}
\usepackage{siunitx}		% Show units
\sisetup{per-mode=fraction}	% Representation of fractions


\usepackage{listings}
\usepackage{scrhack}		% Comma-option \KOMAoption{listof}{leveldown} only effects lstlistoflistings 

\lstdefinestyle{MyMatlab}		% Definition of individual listing-styles
{						% Applications with "\lstinputlisting[style=MyMatlab]{../reflexion/Matlab_Skripte/resample.m}"
	language={Matlab},
	captionpos={t},
	inputencoding={latin1},
	showstringspaces={false},
	frame={tlRB},
	basicstyle=\scriptsize
}

\lstdefinestyle{MyC++}
{
	language={C++},
	tabsize={8},
	captionpos={t},
	frame={tlRB},
	basicstyle=\tiny
}

\lstdefinestyle{MyFortran}
{
	language={[77]Fortran},
	captionpos={t},
	frame={tlRB},
	basicstyle=\tiny
}

\lstdefinestyle{MySh}
{
	language={sh},
	captionpos={t},
	frame={tlRB},
	basicstyle=\tiny
}

\lstdefinestyle{MyGnuplot}
{
	language={Gnuplot},
	captionpos={t},
	frame={tlRB},
	basicstyle=\scriptsize
}

\lstset{literate=%
  {Ö}{{\"O}}1
  {Ä}{{\"A}}1
  {Ü}{{\"U}}1
  {ß}{{\ss}}2
  {ü}{{\"u}}1
  {ä}{{\"a}}1
  {ö}{{\"o}}1
}

\usepackage{rotating}
\usepackage{wrapfig}
\usepackage{tikz}
	\usetikzlibrary{shapes}
	\usetikzlibrary{decorations.pathmorphing}
	\usetikzlibrary{decorations.shapes}
	\usetikzlibrary{shapes.geometric}
	\pgfdeclarelayer{edgelayer}
	\pgfdeclarelayer{nodelayer}
	\pgfsetlayers{edgelayer,nodelayer,main}
	\tikzstyle{none}=[inner sep=0pt]
	\tikzset{decorate with/.style={decorate,decoration={shape backgrounds,shape=#1,shape size=2mm}}}

\definecolor{blue}{rgb}{0.01,0.01,0.95}	%HEX: 0202F2
\definecolor{green}{rgb}{0.01,0.65,0.01}	%HEX: 02A602
\definecolor{red}{rgb}{0.95,0.01,0.01}	%HEX: F20202
\definecolor{brown}{rgb}{0.55,0.27,0.07}	%HEX: 8B4513
\definecolor{violet}{rgb}{0.65,0.05,0.7}	%HEX: A60DB3

\setcounter{tocdepth}{1}	%Legt die Anzeigetiefe des Inhaltsverzeichnisses fest

\renewcommand{\theequation}{\arabic{section}.\arabic{equation}} %Die Nummerierung Formeln wird geändert


\renewcommand{\partheadmidvskip}{\enskip}
\renewcommand{\partformat}{\thepart\autodot}

\renewcommand{\arraystretch}{1.2} %Legt den Faktor fest, um den der Zeilenabstand innerhalb einer Tabelle oder eines Array gedeht wird
\newcommand*\dashline{\hspace{-0.3em}\rotatebox[origin=c]{90}{\scalebox{-0.3}[1]{$-~~-$}}\hspace{-0.3em}}
\newcommand*\longdashline{\hspace{-0.3em}\rotatebox[origin=c]{90}{\scalebox{-0.4}[1]{$-~~-~~-~~-$}}\hspace{-0.3em}}

%\setlength{\oddsidemargin}{20mm} 
%\setlength{\evensidemargin}{20mm} 

\renewcommand*{\chapterheadstartvskip}{\vspace*{-1\baselineskip}}	%legt Abstand vor chapter fest

\newcommand{\CC}[1][]{$\text{C\hspace{0ex}}^{_{_{_{++}}}}					%Write nicer ++ signs in C++
                      \ifthenelse{\equal{#1}{}}{}{\text{\hspace{-.625ex}#1}}$} 
\newcommand{\clang}[1][]{$\text{clang\hspace{0ex}}^{_{_{_{++}}}}		%Write nicer ++ signs in clang++
                      \ifthenelse{\equal{#1}{}}{}{\text{\hspace{-.25ex}(#1)}}$} 
\newcommand{\gCC}[1][]{$\text{g\hspace{0ex}}^{_{_{_{++}}}}				%Write nicer ++ signs in g++
                      \ifthenelse{\equal{#1}{}}{}{\text{\hspace{-.25ex}(#1)}}$} 
                      
\newcommand\coolover[2]{\mathrlap{\smash{%
\overbrace{\phantom{\begin{matrix} #2 %
\end{matrix}}}^{\mbox{$#1$}}}}#2}
                      
\newcommand{\shellcmd}[1]{\indent\indent\texttt{#1}}	%change font for shell entries  
\newcommand{\shellcmdline}[1]{\indent\indent\texttt{\quad#1}} 	%change font for command lines and indention


\makeatother
\usepackage{hyperref}
\definecolor{LinkColor}{rgb}{0,0,0.75}
\hypersetup{                    %Farben der Links im pdf werden festgelegt
colorlinks=true,
linkcolor=LinkColor,
citecolor=LinkColor,
filecolor=LinkColor,
menucolor=LinkColor,
pagecolor=LinkColor,
urlcolor=LinkColor}

\KOMAoption{listof}{leveldown} %Bewirkt, dass listoffigures, listoftables und lstlistoflistings nicht als chapter behandelt werden. Erschenungsbild im Inhaltsverzeichnis und im Dokument selbst (kein automatischer seitenumbruch am Ende der Verzeichnisse).

\pagestyle{scrheadings} %Legt die Art des Seitenformats für alle folgenden Seiten fest. scrheadings: Um bei zweiseitig formatierten Dokumenten (=Bücher, die unterschiedliche "`linke"' und "`rechte"' Seiten haben) den Seitenkopf und -fuß automatisch an die jeweilige Seite anzupassen, gibt es die folgenden Befehle: \ihead, \chead, \ohead, \ifoot, \cfoot, \ofoot für scrheadings wird "`\usepackage{scrpage2}"' benötigt
\clearscrheadfoot %Löscht alle Kopf- und Fußzeilen
\ohead{\headmark}
\automark[section]{chapter}
\ofoot[\pagemark]{\pagemark}		%[plain-Seiten]{normale Seiten}
\setheadsepline{0.4pt} %erzeugt eine Linie der Stärke 0.4pt zwischen Rumpf und Kopfzeile
\setlength{\headsep}{10mm} %Legt den Abstand zwischen der Kopfzeile und dem Rumpf der Seite fest

\hyphenation{CATIA} %definiert die Stellen zum Trennen von Wörter mit "`-"' Beispiel: \hyphenation{er-go-no-mic}

\title{LAMA_Implementation_Doc}
\author{}
\graphicspath{{@CMAKE_SOURCE_DIR@/../doc/guide/}}

% -----------------------------------------------------------------------------------------------
\begin{document}
% -----------------------------------------------------------------------------------------------

\selectlanguage{english}

\numberwithin{equation}{chapter} %legt die Formelnummerierung fest

\thispagestyle{empty} %Kopf und Fußzeile wird für diese Seite ausgeschaltet
\newgeometry{left=25mm,right=25mm,bottom=40mm,top=20mm}
\begin{figure}[h] % Gleiten ist durch Verwendung des H verhindert
\begin{flushright}
\includegraphics[scale=0.15]{./images/wave_logo.png}
\end{flushright}
\end{figure}

\begin{center}
\vspace{2cm}
\huge{WAVE-Inversion}\\
\vspace{0.5cm}
\large{HPC Full-Waveform Inversion Software}
\end{center}

\vfill
\begin{center}
{\Large{\url{wave-toolbox.org}}}


{\small Document created \today}
\end{center}

\newpage 
\thispagestyle{empty}
\begin{center}
{\large
Supported by the German Ministry of Education and Research (BMBF) through the project \textbf{WAVE}, grant 01IH15004A.
}
\end{center}

\cleardoublepage

\pagenumbering{Roman}
\setcounter{page}{1}
\restoregeometry


\newpage

\tableofcontents % Table of contents is inserted \tableofcontens (insert \addcontentsline, so the content is linked correctly)
\addcontentsline{toc}{chapter}{Contents} %"Contents" will be displayed in contents



\pagenumbering{arabic}
\setcounter{page}{1}

\cleardoublepage
%\markboth{}{License}
\chapter*{License}
\addcontentsline{toc}{chapter}{License}

WAVE-Inversion is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License (GNU AGPL v3) as published by the Free Software Foundation, version 3.0 of the License only.\\ 
WAVE-Inversion is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with FDSimulation. See file LICENSE and/or \url{https://www.gnu.org/licenses/agpl-3.0.de.html}.\\
The authors of WAVE-Inversion are listed in file \lstinline{AUTHORS}.

\chapter*{Acknowledgments}

We would like to thank the German Ministry of Education and Research (BMBF) who financially supported this full-waveform inversion toolbox through the project WAVE, grant 01IH15004A.\\
We would also like to acknowledge the developers of the FWI code IFOS2D and IFOS3D (\url{http://www.gpi.kit.edu/Software-FWI.php}). IFOS served as a reference for our new implementation and we further used parts of the user manual of IFOS in this manual.

\chapter*{References}

A list of publications where WAVE-Inversion was used


% -----------------------------------------------------------------------------------------------
\cleardoublepage
\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}
% -----------------------------------------------------------------------------------------------
 
The aim of full-waveform inversion (FWI) is to estimate the elastic or electromagnetic (EM) material parameters in the underground. This can be achieved by minimizing the misfit energy between the modeled and field data using a gradient optimization approach. Because FWI uses the full information content of each seismogram or radargram, structures below the seismic or EM wave length can be resolved. This is a tremendous improvement in resolution compared to travel time tomography \citep{pratt2002the,ernst2007full}. \\
The concept of FWI was originally developed by Albert Tarantola in the 1980s for the acoustic, isotropic elastic, and viscoelastic case \citep{tarantola1984inversion,tarantola1984linearized,tarantola1986a,tarantola1988theoretical}. First numerical implementations were realized at the end of the 1980s \citep{gauthier1986two,mora1987nonlinear,pica1990nonlinear}, but due to limited computational resources, the application was restricted to simple 2D synthetic test problems and small near offset datasets. At the begining of the 1990s the original time domain formulation was transfered to a robust frequency domain approach \citep{pratt1990inverse_a,pratt1990inverse_b}. With the increasing performance of supercomputers moderately sized problems could be inverted with frequency domain approaches. A spectacular result to prove the application of acoustic FWI on laboratory scale was presented by \cite{pratt1999seismic} for ultrasonic tomography measurements on a simple block model. In a numerical blind test \cite{brenders2007full} achieved a very good agreement between their inversion result and the unknown true P-wave velocity $v_p$ model. The parallelization and performance optimizations of the frequency domain approach \citep[see e.g., ][]{sourbier2009fwt2d_a,sourbier2009fwt2d_b} led to a wide range of acoustic FWI applications for problems on different scales, from the global scale, crustal scale over engineering and near surface scale, down to laboratory scale \citep{pratt2004velocity}. Beside the application to geophysical problems, the acoustic FWI is also used to improve the resolution in medical cancer diagnostics \citep{pratt2007sound}. However, all these examples are restricted to the inversion of the acoustic material parameters: P-wave velocity $v_p$, density $\rho$ and additionally the viscoacoustic damping $Q_p$ for the P-waves. Even today the independent 2D FWI of all three isotropic elastic material parameters is still a challenge. Most elastic approaches invert for P-wave velocity only and use empirical relationships to deduce the distribution of S-wave velocity $v_s$ and density \citep{shipp2002two,sheen2006time}. Recently some authors also investigated the independent multiparameter FWI in the frequency domain \citep{choi2008frequency,choi2008two,brossier2009imagerie}.
In order to extract information about the structure and composition of the crust from seismic observations, it is necessary to be able to predict how seismic wavefields are affected by complex structures. Since exact analytical
solutions to the wave equations do not exist for most subsurface configurations, the solutions can be obtained only by numerical methods. \\
When it comes to ground penetrating radar (GPR), FWI was introduced to crosshole GPR first by \cite{ernst2007full} and applied to the field data by \cite{ernst2007application} to recover the relative dielectric permittivity $\varepsilon_r$ and electric conductivity $\sigma$. Then the theory of GPR FWI was improved by \cite{meles2010new} to a vector formalisation and to simultaneously update  $\varepsilon_r$ and $\sigma$. For more details about the development of GPR FWI in the last decade, the readers are recommended to the review paper of \cite{klotzsche2019review}.\\
For iterative calculations of synthetic seismograms or radargrams with limited computer resources fast and accurate modeling methods are needed. The FWI program WAVE-Inversion (C++) is using the finite difference simulation software WAVE-Simulation (insert link). It is also possible to use the WAVE-Inversion library with different simulation software.\\
In the following sections, by taking 3D elastic wave equation as an example, we give a short description of the derivation of the gradients of the objective function and how the program is used and executed. In the current version of WAVE-Inversion, FWI of viscoelastic is possible with the passive parameters $\tau^p$ and $\tau^s$, which actually use the same gradient derived from elastic wave equation. The others such as the acoustic, EM and visco-EM wave equations are shown in the appendix \ref{sec:Acoustic_wave_equation}-\ref{sec:Visco_EM_wave_equation}.
We recommend you to read the theory of seismic FWI from IFOS2D and IFOS3D first for better understanding of the adjoint method we used. 

% -----------------------------------------------------------------------------------------------
\cleardoublepage
\part{Theory of Full-Waveform Inversion}

\chapter{Derivation of the seismic gradients of the objective function}
\section{Elastic wave equation}
\label{sec:elastic}
The elastic wave equations for stress and velocity.
\begin{align}
\label{eqn:elastic_wave_stress_xx}
\rho\pdv{v_i}{t}&=\pdv{\sigma_{ij}}{x_j}+ f_i\\
\pdv{\sigma_{ii}}{t} &= \lambda \pdv{v_k}{x_k} + 2\mu \pdv{v_i}{x_i}+\pdv{\sigma_{ii0}}{t}\\
\pdv{\sigma_{ij}}{t} &= \mu \left(\pdv{v_i}{x_j} +\pdv{v_j}{x_i}\right), \quad i \neq j
\end{align}
We explicitly write it in 3D case:
\begin{align}
\rho\pdv{v_x}{t}&=\pdv{\sigma_{xx}}{x}+\pdv{\sigma_{xy}}{y} + \pdv{\sigma_{xz}}{z}+ f_x\\
\rho\pdv{v_y}{t}&=\pdv{\sigma_{xy}}{x}+\pdv{\sigma_{yy}}{y} + \pdv{\sigma_{yz}}{z} + f_y\\
\rho\pdv{v_z}{t}&=\pdv{\sigma_{xz}}{x}+\pdv{\sigma_{yz}}{y} + \pdv{\sigma_{zz}}{z} + f_z\\ 
\label{eqn:elastic_wave_stress_xx}
\pdv{\sigma_{xx}}{t} &= (\lambda+2\mu) \pdv{v_x}{x} + \lambda \pdv{v_y}{y} + \lambda \pdv{v_z}{z} + \pdv{\sigma_{xx0}}{t}\\
\label{eqn:elastic_wave_stress_yy}
\pdv{\sigma_{yy}}{t} &= \lambda \pdv{v_x}{x} + (\lambda+2\mu) \pdv{v_y}{y} + \lambda \pdv{v_z}{z} + \pdv{\sigma_{yy0}}{t}\\ 
\label{eqn:elastic_wave_stress_zz}
\pdv{\sigma_{zz}}{t} &= \lambda \pdv{v_x}{x} +  \lambda \pdv{v_y}{y} + (\lambda+2\mu) \pdv{v_z}{z} + \pdv{\sigma_{zz0}}{t}\\
\pdv{\sigma_{xy}}{t} &= \mu \left(\pdv{v_x}{y} +\pdv{v_y}{x}\right)\\
\pdv{\sigma_{yz}}{t} &= \mu \left(\pdv{v_y}{z} +\pdv{v_z}{y}\right) \\
\pdv{\sigma_{xz}}{t} &= \mu \left(\pdv{v_x}{z} +\pdv{v_z}{x}\right)
\end{align}
Sum equation \ref{eqn:elastic_wave_stress_xx} + \ref{eqn:elastic_wave_stress_yy} + \ref{eqn:elastic_wave_stress_zz}:
\begin{equation}
\begin{aligned}
 \pdv{\sigma_{xx}}{t}+\pdv{\sigma_{yy}}{t}+\pdv{\sigma_{zz}}{t} =& \left(3\lambda+2\mu\right)\left(\pdv{v_x}{x}+\pdv{v_y}{y}+ \pdv{v_z}{z}\right) + 3 \pdv{p_0}{t}\\ 
 p_0 =& \frac{1}{3} \left( \sigma_{xx0}+\sigma_{yy0}+\sigma_{zz0} \right)
\end{aligned}
\end{equation}
where $p_0$ is a point source.\\
Then equation \ref{eqn:elastic_wave_stress_xx} to \ref{eqn:elastic_wave_stress_zz} can be rewritten:
\begin{align}
\label{eqn:elastic_wave_velocity_xx}
\pdv{v_x}{x}=\frac{1}{2\mu} \left[\pdv{\sigma_{xx}}{t} - \frac{\lambda}{3\lambda+2\mu} \left(\pdv{\sigma_{xx}}{t}+\pdv{\sigma_{yy}}{t}+\pdv{\sigma_{zz}}{t}-3\pdv{p_0}{t}\right)\right]\\
\pdv{v_y}{y}=\frac{1}{2\mu} \left[\pdv{\sigma_{yy}}{t} - \frac{\lambda}{3\lambda+2\mu} \left(\pdv{\sigma_{xx}}{t}+\pdv{\sigma_{yy}}{t}+\pdv{\sigma_{zz}}{t}-3\pdv{p_0}{t}\right)\right]\\
\label{eqn:elastic_wave_velocity_zz}
\pdv{v_z}{z}=\frac{1}{2\mu} \left[\pdv{\sigma_{zz}}{t} - \frac{\lambda}{3\lambda+2\mu} \left(\pdv{\sigma_{xx}}{t}+\pdv{\sigma_{yy}}{t}+\pdv{\sigma_{zz}}{t}-3\pdv{p_0}{t}\right)\right]
\end{align}
We change the position of time derivatives from right to left and get:
\begin{align}
A \left( \pdv{\sigma_{xx}}{t}-\frac{NB}{A} \pdv{p_0}{t} \right) + B \pdv{\sigma_{yy}}{t}+B\pdv{\sigma_{zz}}{t}=\pdv{v_x}{x}\\
B\pdv{\sigma_{xx}}{t} + A \left( \pdv{\sigma_{yy}}{t}-\frac{NB}{A} \pdv{p_0}{t} \right)+B\pdv{\sigma_{zz}}{t}=\pdv{v_y}{y}\\
B\pdv{\sigma_{xx}}{t} + B \pdv{\sigma_{yy}}{t}+A \left( \pdv{\sigma_{zz}}{t}-\frac{NB}{A} \pdv{p_0}{t} \right)=\pdv{v_z}{z}
\end{align}
with:
\begin{align}
A=&\frac{1}{2\mu}-\frac{\lambda}{2\mu(N\lambda+2\mu)}\\
B=&-\frac{\lambda}{2\mu(N\lambda+2\mu)}
\end{align}
where $N\in[2,3]$ (Number of dimensions).\\
Then we obtain the matrix formulation of forward problem as follows:
\begin{equation}
 M\left( \pdv{}{t}\mathbf{u}-\mathbf{s} \right) =Q\mathbf{u}
\end{equation}
\begin{equation}
\mathbf{u}=\left(v_x,v_y,v_z,\sigma_{xx},\sigma_{yy},\sigma_{zz},\sigma_{xy},\sigma_{yz} ,\sigma_{xz} \right)^T
\end{equation}
\begin{equation}
\mathbf{s}=\left(\frac{f_x}{\rho}, \frac{f_y}{\rho}, \frac{f_z}{\rho},\frac{NB}{A} \pdv{p_0}{t},\frac{NB}{A} \pdv{p_0}{t},\frac{NB}{A} \pdv{p_0}{t},0,0,0\right)^T
\end{equation}
\begin{equation}
Q=
 \begin{pmatrix}
   0          & 0         & 0         & \pdv{}{x} & 0         & 0         & \pdv{}{y} & 0         & \pdv{}{z}\\
   0          & 0         & 0         & 0         & \pdv{}{y} & 0         & \pdv{}{x} & \pdv{}{z} & 0        \\
   0          & 0         & 0         & 0         & 0         & \pdv{}{z} & 0         & \pdv{}{y} & \pdv{}{x}\\
   \pdv{}{x}  & 0         & 0         & 0         & 0         & 0         & 0         & 0         & 0        \\
   0          & \pdv{}{y} & 0         & 0         & 0         & 0         & 0         & 0         & 0        \\
   0          & 0         & \pdv{}{z} & 0         & 0         & 0         & 0         & 0         & 0        \\
   \pdv{}{y}  & \pdv{}{x} &  0        & 0         & 0         & 0         & 0         & 0         & 0        \\
   0          & \pdv{}{z} & \pdv{}{y} & 0         & 0         & 0         & 0         & 0         & 0        \\
   \pdv{}{z}  & 0         & \pdv{}{x} & 0         & 0         & 0         & 0         & 0         & 0        \\
 \end{pmatrix}, \quad Q^{*}=-Q
\end{equation}

\begin{equation}
M=
 \begin{pmatrix}
   \rho       & 0         & 0         & 0         & 0         & 0         & 0         & 0         & 0       \\
   0          & \rho      & 0         & 0         & 0         & 0         & 0         & 0         & 0        \\
   0          & 0         & \rho      & 0         & 0         & 0         & 0         & 0         & 0        \\
   0          & 0         & 0         & A         & B         & B         & 0         & 0         & 0        \\
   0          & 0         & 0         & B         & A         & B         & 0         & 0         & 0        \\
   0          & 0         & 0         & B         & B         & A         & 0         & 0         & 0        \\
   0          & 0         & 0         & 0         & 0         & 0         & 1/\mu      & 0         & 0        \\
   0          & 0         & 0         & 0         & 0         & 0         & 0         & 1/\mu      & 0        \\
   0          & 0         & 0         & 0         & 0         & 0         & 0         & 0         & 1/\mu     \\
 \end{pmatrix}, \quad M^{*}=M
\end{equation}
where $^{*}$ is the transpose conjugate operator and equals the transpose operator for the real values.

\section{1st order adjoint method}
The misfit function $\Phi_1$:
\begin{equation}
 \Phi_1(\mathbf{m}) = \Phi_1(\mathbf{u}) = \frac{1}{2} || \mathbf{d}^{syn} - \mathbf{d}^{obs} ||_2^2 = \frac{1}{2} || R\mathbf{u}(\mathbf{m}) - \mathbf{d}^{obs} ||_2^2 \\
\end{equation}
where the synthetic data $\mathbf{d}^{syn}$ is extracted by the restriction operator $R$ from the synthetic wavefield $\mathbf{u}$. $\mathbf{d}^{obs}$ is the observed data. To identify with the 2$nd$ order adjoint method used in truncated Newton method, we add a subscript ``1'' to the misfit function used by the 1$st$ order adjoint method in this manual.\\
Augmented functional $L_1$ used in 1st order adjoint method:
\begin{equation}
 L_1(\mathbf{m}, \mathbf{u},\mathbf{u}_{1}) = \Phi_1(\mathbf{u}) - \langle \mathbf{u}_{1}, F(\mathbf{u},\mathbf{m}) \rangle_W \\
\end{equation}
with
\begin{equation}
\begin{split}
\label{eqn:initialCondition11}
 & F(\mathbf{u},\mathbf{m}) = M \partial_{t} \mathbf{u}  - Q\mathbf{u} - M \mathbf{s} = 0 \\
 & \mathbf{m} = (\rho, \lambda, \mu)^T, \mathbf{u}|_{t=0} = 0, \mathbf{u}|_{x\in \partial \Omega} = 0
 \end{split}
\end{equation}
where the inner product $\langle \mathbf{h}_1, \mathbf{h}_2 \rangle_W$ in the domain $W=\Omega \times [0, T]$ is defined by ($\Omega$ is the spatial computation domain)\\
\begin{equation}
 \langle \mathbf{h}_1, \mathbf{h}_2 \rangle_W = \int_0^T \int_\Omega \mathbf{h}_1^{*}(x,t) \mathbf{h}_2(x,t) dt dx\\
\end{equation}
For any $\mathbf{u}_{1}$:
\begin{equation}
 L_1(\mathbf{m}, \mathbf{u},\mathbf{u}_{1}) = \Phi_1(\mathbf{u}) \\
\end{equation}
We write the augmented functional explicitly:
\begin{equation}
\label{eqn:AugmentFunctional}
 L_1(\mathbf{m}, \mathbf{u},\mathbf{u}_{1}) = \frac{1}{2} \int_0^T \int_\Omega (R\mathbf{u} - \mathbf{d}^{obs})^2 dt dx - \int_0^T \int_\Omega \mathbf{u}_{1}^{*} (M \partial_{t} \mathbf{u} - Q \mathbf{u} - M \mathbf{s})  dt dx\\
\end{equation}
If the final condition and boundary condition of $\mathbf{u}_{1}$ are satisfied by:
\begin{equation}
\label{eqn:initialCondition22}
 \mathbf{u}_{1}|_{t=T} = 0, \mathbf{u}_{1}|_{x\in \partial \Omega} = 0\\
\end{equation}
Based on the initial and final condition shown in \ref{eqn:initialCondition11} and \ref{eqn:initialCondition22}, we integrate in time by parts \citep{yang2016review}:
\begin{equation}
\begin{split}
\int_0^T \int_\Omega \mathbf{u}_{1}^{*} (M \partial_{t} \mathbf{u}) dt dx 
&=  \int_\Omega \mathbf{u}_{1}^{*} M\mathbf{u}|_0^T dx - \int_0^T \int_\Omega (M^{*} \partial_{t} \mathbf{u}_{1})^{*} \mathbf{u} dt dx\\
&= -\int_0^T \int_\Omega (M \partial_{t} \mathbf{u}_{1})^{*} \mathbf{u} dt dx
\end{split}
\end{equation}
Similarly, based on the boundary condition shown in \ref{eqn:initialCondition11} and \ref{eqn:initialCondition22}, we integrate in space by parts:
\begin{equation}
\begin{split}
\int_0^T \int_\Omega \mathbf{u}_{1}^{*} Q \mathbf{u} dt dx 
&=-\int_0^T \int_\Omega (Q \mathbf{u}_{1})^{*} \mathbf{u} dt dx
\end{split}
\end{equation}
Then we get:
\begin{equation}
\begin{split}
L_1(\mathbf{m}, \mathbf{u},\mathbf{u}_{1})
  = \frac{1}{2} \int_0^T \int_\Omega (R\mathbf{u} - \mathbf{d}^{obs})^2 dt dx + \int_0^T \int_\Omega ((M \partial_{t} \mathbf{u}_{1})^{*} \mathbf{u} - (Q \mathbf{u}_{1})^{*} \mathbf{u} + (M \mathbf{u}_{1})^{*} \mathbf{s})  dt dx
 \end{split}
\end{equation}
The derivative of $L_1$ with respect to wavefields $\mathbf{u}$:
\begin{equation}
 \pdv{L_1}{\mathbf{u}} = \int_0^T \int_\Omega \left((R\mathbf{u} - \mathbf{d}^{obs})R + M \partial_{t} \mathbf{u}_{1} - Q \mathbf{u}_{1}\right)^{*} dt dx
\end{equation}
To satisfy the final condition of $\mathbf{u}_{1}$ (equation \ref{eqn:initialCondition22}), the time needs to be reversed by substituting $t^{'}=T-t$ ($\partial_{t^{'}} = -\partial_{t}$ and $dt^{'}=-dt$) in the above equation. Thus we get
\begin{equation}
 \pdv{L_1}{\mathbf{u}} = -\int_T^0 \int_\Omega \left( R^{*}(R\mathbf{u} - \mathbf{d}^{obs}) - M \partial_{t^{'}} \mathbf{u}_{1} - Q \mathbf{u}_{1} \right)^{*} dt^{'} dx
\end{equation}
By making $\pdv{L_1}{\mathbf{u}} = 0$, therefore we obtain the adjoint state equation:
\begin{equation}
\begin{aligned}
\label{eqn:AdjointEquation1}
& M \partial_{t^{'}} \mathbf{u}_{1} = -Q \mathbf{u}_{1} + R^{*}(R\mathbf{u} - \mathbf{d}^{obs})
\end{aligned}
\end{equation}
where the wavefield residual $R^{*}(R\mathbf{u} - \mathbf{d}^{obs}) $ is used as the sources for back propagation. The 1$st$ order adjoint wavefields:
\begin{equation}
\mathbf{ u}_1=\left(v_{1x},v_{1y},v_{1z},\sigma_{1xx},\sigma_{1yy},\sigma_{1zz},\sigma_{1xy},\sigma_{1yz},\sigma_{1xz}\right)^T
\end{equation}
The 1st order adjoint equation (anti self-adjoint) is:
\begin{equation}
\label{eqn:AdjointEquation11}
\mathbf{u}_{1}:
\begin{cases}
\rho\pdv{v_{1i}}{t^{'}}=-\pdv{\sigma_{1ij}}{x_j} + R^{*}(R v_i -v_i^{obs})\\
\pdv{\sigma_{1ii}}{t^{'}} = -\lambda \pdv{v_{1k}}{x_k} - 2\mu \pdv{v_{1i}}{x_i} + R^{*}(R p - p^{obs})\\
\pdv{\sigma_{1ij}}{t^{'}} = -\mu \left(\pdv{v_{1i}}{x_j} +\pdv{v_{1j}}{x_i}\right), \quad i \neq j
\end{cases}
\end{equation}
where $p=\frac{1}{N} \sum \sigma_{ii}$ and $t^{'}=T-t$ (the reversed time).
If one prefers to use the same forward solver for both the forward problem and adjoint problem, one can use the equivalent equation with a slight change of the adjoint wavefields, as follows:
\begin{equation}
\begin{align}
&\mathbf{u}_{1}^{’} = \varLambda \mathbf{u}_{1} = \left(v_{1x}^{’},v_{1y}^{’},v_{1z}^{’},\sigma_{1xx}^{’},\sigma_{1yy}^{’},\sigma_{1zz}^{’},\sigma_{1xy}^{’},\sigma_{1yz}^{’},\sigma_{1xz}^{’}\right)^T \\
&\mathbf{u}_{1} = \varLambda \mathbf{u}_{1}^{’}, \quad diag(\varLambda) = \left(1,1,1,-1,-1,-1,-1,-1,-1 \right)
\end{align}
\end{equation}
\begin{equation}
\label{eqn:AdjointEquation111}
\mathbf{u}_{1}^{’}:
\begin{cases}
\rho\pdv{v_{1i}^{’}}{t^{'}}=\pdv{\sigma_{1ij}^{’}}{x_j} + R^{*}(R v_i -v_i^{obs})\\
\pdv{\sigma_{1ii}^{’}}{t^{'}} = \lambda \pdv{v_{1k}^{’}}{x_k} + 2\mu \pdv{v_{1i}^{’}}{x_i} - R^{*}(R p - p^{obs})\\
\pdv{\sigma_{1ij}^{’}}{t^{'}} = \mu \left(\pdv{v_{1i}^{’}}{x_j} +\pdv{v_{1j}^{’}}{x_i}\right), \quad i \neq j
\end{cases}
\end{equation}
The derivative of $L_1$ with respect to model parameters $\mathbf{m}$ can be obtained from Eq. \ref{eqn:AugmentFunctional} as follows:
\begin{equation}
\begin{align}
 \pdv{\Phi_1}{\mathbf{m}} &= \pdv{L_1}{\mathbf{u}}\pdv{\mathbf{u}}{\mathbf{m}} + \pdv{L_1}{\mathbf{m}} =  \pdv{L_1}{\mathbf{m}} \\
 &= -\int_0^T \mathbf{u}_{1}^{*} \pdv{M}{\mathbf{m}} \left( \partial_{t}\mathbf{u} - \mathbf{s} \right) dt = -\int_0^T (\varLambda \mathbf{u}_{1}^{'})^{*} \pdv{M}{\mathbf{m}} \left( \partial_{t}\mathbf{u} - \mathbf{s} \right) dt
\end{align}
\end{equation}
The gradient of the objective function $\Phi_1(\mathbf{m})$ with respect to elastic parameters are shown as:
\begin{align}
 \pdv{\Phi_1}{\rho}&=-\int_0^T \left( \pdv{v_x}{t} v_{1x}^{'} + \pdv{v_y}{t} v_{1y}^{'} + \pdv{v_z}{t} v_{1z}^{'} \right) dt\\
 \pdv{\Phi_1}{\lambda}&=\pdv{A}{\lambda}\int_0^T  \left(\pdv{\sigma_{xx}}{t}+\pdv{\sigma_{yy}}{t}+\pdv{\sigma_{zz}}{t}\right) \left(\sigma_{1xx}^{'}+\sigma_{1yy}^{'}+\sigma_{1zz}^{'}\right)  dt\\
 \pdv{\Phi_1}{\mu}&=\int_0^T \left\{\pdv{A}{\mu}\left(\pdv{\sigma_{xx}}{t}\sigma_{1xx}^{'}+\pdv{\sigma_{yy}}{t}\sigma_{1yy}^{'}+\pdv{\sigma_{zz}}{t}\sigma_{1zz}^{'}\right)\right. \\
 &+ \pdv{B}{\mu} \left[\left(\pdv{\sigma_{yy}}{t}+\pdv{\sigma_{zz}}{t}\right)\sigma_{1xx}^{'}
 + \left(\pdv{\sigma_{xx}}{t}+\pdv{\sigma_{zz}}{t}\right)\sigma_{1yy}^{'}
  + \left(\pdv{\sigma_{xx}}{t}+\pdv{\sigma_{yy}}{t}\right)\sigma_{1zz}^{'}\right]\\
  &-\left.\frac{1}{\mu^2}\left(\pdv{\sigma_{xy}}{t}\sigma_{1xy}^{'}+\pdv{\sigma_{yz}}{t}\sigma_{1yz}^{'}+\pdv{\sigma_{xz}}{t}\sigma_{1xz}^{'}\right)\right\} dt
\end{align}
with:
\begin{align}
 \pdv{A}{\lambda}&=\pdv{B}{\lambda}=-\frac{1}{(N\lambda+2\mu)^2} \\
 \pdv{B}{\mu}&=\frac{N\lambda^2+4\mu\lambda}{2\mu^2(N\lambda+2\mu)^2} \\
 \pdv{A}{\mu}&=-\frac{1}{2\mu^2}+\pdv{B}{\mu}
\end{align}
% -----------------------------------------------------------------------------------------------

\part{Software Guide to WAVE-Inversion}
\chapter{Software Requirements and Quick Guide}

WAVE-Inversion is developed as a part of the WAVE-project (\url{http://wave-toolbox.org}) and is a seismic full-waveform inversion framework. 

\section{Software Requirements}

To begin with, a \CC-compiler has to be available. A compiler with  \CC[11]-standard support is needed. To compile WAVE-Inversion, make sure a couple of libraries are installed and running properly. All necessary libraries for proper usage and a short description can be seen in table \ref{tab:pack}. A \CC-compiler and LAMA are mandatory whereas the other libraries and software are optional to execute WAVE-Inversion.
As the software is meant for high performance computing (HPC) on cluster networks, it is primarily designed to run on Linux-platforms. The code has been tested using \gCC[4.9.3], \clang[3.9] as a  \CC-compiler and using OpenMPI (1.7.2, 1.10.0) as MPI implementation.
\begin{table}[h!]
\caption{List of necessary libraries, packages and compiler.}\label{tab:pack}
\centering
\begin{adjustbox}{width=1\textwidth,center=\textwidth}
	\begin{tabular}{lll}
	\toprule
	Program & Brief description & Weblink \\
	\midrule
	\CC-compiler	& The code is written in \CC[], the compiler	has 		& \\
										& to be compatible to compile \CC[11]-standard					& \\
LAMA 				& The LAMA-framework for high performance			& \url{https://www.libama.org} \\
	& computing 	(HPC)							    & \\
	\midrule
	OpenMPI			& Implementation of MPI for parallelised  			& \url{https://www.open-mpi.org} \\
										& calculations						& \\
		boost					& Implementation of the boost-library	for  				& \url{https://www.boost.org}		\\
										& debugging																& \\										
	Python				& Models can be generated using Python 		& \url{https://www.python.org}\\
	Matlab				& Models can be generated using Matlab		& \url{http://www.mathworks.com}\\	
	
	
	Seismic Un*x	& 	Seismic processing package, to generate a  	& \url{http://www.cwp.mines.edu/cwpcodes}\\ 
											&  Seismogram from SU-data  															& \\
	
	
	Sphinx				& 	A Python documentation generator 							& \url{http://www.sphinx-doc.org}\\
	doxygen			& 	Generation of documentation from annotated				& \url{http://www.doxygen.org}\\
										& \CC-code 															& \\
	googletest & Implementation of gtest for unit-tests & \url{http://code.google.com/p/googletest}\\
	\bottomrule
	\end{tabular}
	\end{adjustbox}
\end{table}

\section{Quick Guide}

% install folder extra, e.g., for different compiler options, one build folder only 
% suggested to create different build folder and install folder and copy the par folder 

\subsection{Installation}
To get started, download WAVE-Inversion. 

You can download the software together with WAVE-Simulation directly from \url{https://github.com/WAVE-Toolbox/Installation} and unzip the folder (e.g., by entering \shellcmd{tar -zxvf Installation-master.zip}).

Alternatively you can also get WAVE-Inversion by entering the command: \\\shellcmdline{git clone https://github.com/WAVE-Toolbox/Installation.git}

In the \shellcmd{tar -zxvf Installation-master} folder you will find a readme file and an \shellcmd{install.sh} script. Run the script where you want to have the installation by entering: \\\shellcmdline{./install.sh}

The script installs (clones, configures and compiles) the required LAMA-framework, the WAVE-Simulation and the WAVE-Inversion and the optional Geographer distribution.

The runtime configuration (such as the FD grid) can be changed in the \shellcmd{configuration.txt} file, located in the directory \shellcmd{par/configuration/}. A list of all input variables and their dependencies can be found in section \ref{sec:config}. 

To create a html and LaTeX or pdf documentation of the software code itself, you can generate a doxygen documentation. Therefore change the directory to \shellcmd{build/} and run the command \shellcmd{make doc}. After running doxygen, the html, LaTeX and Pdf version of the reference manual can be found in \shellcmd{build/doc/doxygen/} and \shellcmd{build/doc/guide/}.

\subsection{Example}
To run the inversion change the directory to: \\\shellcmdline{par/}\\
and start the program by running the shell script \shellcmd{start\_Inversion.sh} with  \\\shellcmdline{source start\_Inversion.sh}

The synthetic Seismogram or Radargram data is saved in \shellcmd{par/seismograms/} and can be plotted by using either the \shellcmd{plotSeismogram.m} Matlab-script or by executing the Python-script \shellcmd{plotSeismogram.py}.
As a first test, run the default example in WAVE-Simulation to obtain the seismogram. 


\section{Configuration}
\label{sec:config}
As mentioned in the quick guide, the configuration can be found in \shellcmd{par/configuration/}. In the \shellcmd{configuration.txt} file input variables can be added or changed. A list of all variables and config parameters that can be added and changed can be found in the tables \ref{tab:config_IO} to \ref{tab:config_thresholds}. In the following subsections you can find a detailed description of all parameters.

\subsection{General in- and output}
\begin{table}[h!]
\caption[List of in- and output configuration parameters.]{List of in- and output configuration parameters, that can be added and changed in the config-file.}\label{tab:config_IO}
\centering
\begin{adjustbox}{width=1\textwidth,center=\textwidth}
	\begin{tabular}{llll}
	\toprule
         Variable                 & Short description                                                   & Type   & Example value \\
	\midrule
         fieldSeisName            & Filename-prefix of field data                                                  & string & ci/rectangle.true  \\    
         writeGradient            & Write gradient to file (0, 1, 2)                                             &  int   & 1 \\
         writeGradientPerShot     & Write gradient of each shot separately to file                      &  int   & 0 (=no) \\
         gradientFilename         & Filename-prefix of gradients                                                   & string & gradients/grad \\     
         logFilename              & Name of log file                                                    & string & logs/steplengthSearch.log  \\
         writeAdjointSource & Write adjoint source of each shot separately to file                      &  int   & 0 (=no) \\
	\bottomrule
	\end{tabular}
	\end{adjustbox}
\end{table}
FWI is an algorithm which needs and produces a lot of data. In this part, the general in- and output for inversion is described apart from the simulation options that have been given in WAVE-Simulation user manual. Some in-/output options for inversion are very specific and therefore described in the corresponding section and table \ref{tab:config_IO}.

The core of every FWI is the field data that should be inverted. The folder and basename of the field data has to be defined with the parameter \verb+fieldSeisName+. The program is automatically appending the shot number and the seismogram type (p, vx, vy, vz) or radargram type (ez, ex, ey, hz). For example, if the parameter \verb+fieldSeisName+ is set to \verb+seismograms/fieldData+ and pressure seismograms are inverted, the complete file name that is tried to be read is \verb+seismograms/fieldData.shot_0.p.mtx+. Shot numbers are defined by user's own. Synthetic seismograms or radargrams are saved in the same way with the filename \verb+SeismogramFilename+. Note that seismograms or radargrams with \verb+.It_0.+ correspond to the seismograms or radargrams of the initial model of each workflow stage where \verb+It+ means iteration.

With the parameters \verb+writeGradientPerShot+ and \verb+writeGradient+, it can be decided whether the gradients per shot and the summed gradients over all shots should be saved to disk. If \verb+writeGradientPerShot+ = 1 or \verb+writeGradient+ = 1, the gradients are stored with the name \verb+gradientFilename+. The workflow stage and iteration number and the parameter class are automatically appended, e.g., with \verb+gradients/grad+ as \verb+gradientFilename+ the first gradient with respect to the P-wave velocity will be \verb+gradients/grad.stage_1.It_1.vp.mtx+ if \verb+writeGradient+ = 1 and \verb+FileFormat+ = 1. In joint structural inversion (JSI), the additional model cross-gradient and its derivative will be stored as \verb+gradients/grad.stage_1.It_1.vp.crossGradient.mtx+\\
and \verb+gradients/grad.stage_1.It_1.vp.crossGradientDerivative.mtx+ if \verb+writeGradient+ = 2 and \verb+FileFormat+ = 1. In case of regularization is used by setting \verb+stablizingFunctionalType+ != 0, the gradient of a stabilizing functional will be stored as\\ \verb+gradients/grad.stage_1.It_1.vp.stabilizingFunctionalGradient.mtx+\\ if \verb+writeGradient+ = 2 and \verb+FileFormat+ = 1.

The program will create a log file with the name specified by \verb+logFilename+. The file contains the misfit evolution (last column) for each stage and iteration (first two columns). The third column (optimum step length) is the step length which was used for the model update. The next three columns correspond to the three step length of the inexact line search and the subsequent three columns are the corresponding data misfits. Note that these three data misfits could be calculated only for a subset of the shots depending on the setting, e.g., \verb+testShotIncr+ > 1. Rows with iteration 0 denote the initial data misfit of the corresponding workflow stage. \verb+writeAdjointSource+ can be used to output the adjoint source of each shot, as well as the terms defined by different objective functions. For example, the frequency-wavenumber (FK) spectra of the synthetic data ( \verb+misfitType+=4) and observed data in FK objective function or envelope of the data in envelope objective function ( \verb+misfitType+=8).

\subsection{General inversion setting}
\begin{table}[h!]
\caption[List of general inversion configuration parameters.]{List of general inversion configuration parameters, that can be added and changed in the config-file.}\label{tab:config_general_inversion_setting}
\centering
\begin{adjustbox}{width=1\textwidth,center=\textwidth}
	\begin{tabular}{llll}
	\toprule
         Variable                 & Short description                                                   & Type   & Example value \\
	\midrule                 
         inversionType               & Type of inversion (0, 1, 2 and 3)                                                    & int & 1  \\
         exchangeStrategy               & Strategy of model exchange (0, 1, 2, 3, 4, 5 and 6)                                                    & int & 0  \\
         breakLoopType               & Type of breaking loop (0, 1 and 2)                                                    & int & 0  \\
         misfitType               & Type of misfit (L2, L7, L8, L2781, L2782) & string & L2  \\
         multiMisfitType               & Type of multi-misfit (L278, L25678)                                                     & string & L278  \\
         saveMultiMisfits & Save multi-misfits (0, 1) & int & 0 \\
         useRandomSource & Use random sources (0, 1, 2) & int & \num{0} \\
         useSourceEncode & Use encoded sources (0, 1, 2) & int & \num{0} \\
         gradientDomain & Gradient in time or frequency domain (0, 1, 2) & int & \num{0} \\
         gradientKernel & Use migration or tomographic kernel (0, 1, 2, 3, 4) & int & \num{0} \\
         DTInversion              & Factor of DT to save time in gradient calculation   &  int   & 1 \\
         DHInversion              & Factor of DH to save memory in gradient calculation   &  int   & 1 \\
         optimizationType         & Type of optimization                                     & string & conjugateGradient \\
         workflowFilename         & Name of workflow file                                               & string & workflow/workflow.txt \\
         parametersation            & Parameterisation type (0, 1, 2, 3 and 4) &  int   & 3  \\
         effectiveParameterisation            & Visco parameterisation type (0 and 1) &  int   & 0  \\
         aArchie            & Tortuosity factor in Archie's equation &  double   & 2.0  \\
         mArchie            & Porosity exponent in Archie's equation &  double   & 0.4  \\
         nArchie            & Saturation exponent in Archie's equation &  double   & 1.13  \\
         stablizingFunctionalType            & Regularization type (0, 1 and 2) &  int   & 0  \\
         focusingParameter            & Focusing parameter used in stablizing functional &  double   & 1.0e-1  \\
         maxIterations            & \begin{tabular}{@{}l@{}}{Maximum number of inversion iterations} \\{per workflow stage}\end{tabular} &  int   & 20  \\
	\bottomrule
	\end{tabular}
	\end{adjustbox}
\end{table}

\subsubsection{Individual/Joint inversion} 
Due to that we have included the forward solver of both seismic wave equations and EM wave equations in WAVE-Simulation, it is possible to run an individual inversion of one wave by \verb+inversionType+=1 or run a joint inversion of seismic and EM waves by \verb+inversionType+=2 or 3 in table \ref{tab:config_general_inversion_setting}. \verb+inversionType+=2 and 3 are corresponding to JSI and joint petrophysical inversion (JPI), respectively. In JSI, it is assumed that the coupled parameter models share similar structures and the structural similarity is enhanced by cross-gradient during the inversion \citep{gallardo2003characterization}. JPI is based on empirical or experimental petrophysical relationships that connect different physical parameters through the common petrophysical properties, i.e., porosity and saturation \citep{qin2022indirect}. If you work with OpenMPI, you may use the following command in \shellcmdline{start\_Inversion.sh} to run an individual inversion:\\
    \shellcmd{mpirun ./../build/bin/Inversion "configuration/configuration\_Elastic2D.txt"}\\
or run a joint inversion by:\\
    \shellcmd{mpirun ./../build/bin/Inversion "configuration/configuration\_Elastic2D.txt" "configuration/configuration\_TMEM2D.txt"}
    
For the joint inversion, \verb+inversionType+>0 must be the same in \shellcmd{configuration\_Elastic2D.txt} and \shellcmd{configuration\_TMEM2D.txt}. Besides, you can set \verb+inversionType+=1 in two configuration files to run two individual inversion or set \verb+inversionType+=1 in one and \verb+inversionType+=0 in another to run an individual inversion.

The parameter \verb+exchangeStrategy+ defines the rule of model self-constraint and mutual constraint in joint inversion. Hence for an individual inversion, \verb+exchangeStrategy+ has to be 0. In case of JSI, \verb+exchangeStrategy+=1 represents only one parameter of each model, namely S-wave velocity $v_s$ in seismic model and dielectric permittivity $\varepsilon$ in EM model, will be used to calculate the cross-gradient and mutually constrain each other. The other parameters of each model, namely P-wave velocity $v_p$ and density $\rho$ in seismic model and electric conductivity $\sigma$ in EM model, will be self-constrained by their corss-gradient with $v_s$ or $\varepsilon$. \verb+exchangeStrategy+=2 means the averaged model derivative of all parameters in each model is used to calculate the cross-gradient. In this case, all parameters contribute equally in JSI. For JPI, more options of \verb+exchangeStrategy+ can be chosen. \verb+exchangeStrategy+=0 means there is no petrophysical parameter exchange between to inversions, but each inversion are constrained by petrophysical relationships. \verb+exchangeStrategy+=1 means only the porosity $\phi$ calculated by seismic inversion and the saturation $S_w$ calculated by GPR inversion will be exchanged to each other. \verb+exchangeStrategy+=2 represents both $\phi$ and $S_w$ will be exchanged iteratively. \verb+exchangeStrategy+=3 is the same as \verb+exchangeStrategy+=1 but the parameter exchange is only implemented at the end of each inversion stage. \verb+exchangeStrategy+=4 is the same as \verb+exchangeStrategy+=1 but the parameter exchange is only implemented once at the end of each inversion. \verb+exchangeStrategy+=5 is the same as \verb+exchangeStrategy+=3 but in the non-exchange gap petrophysical parameters are not updated. \verb+exchangeStrategy+=6 is the same as \verb+exchangeStrategy+=4 but in the non-exchange gap petrophysical parameters are not updated. \verb+exchangeStrategy+=5 and 6 give the inversion more freedom, however, it does not mean better inversion results \cite{qin2022indirect}.

In case of two configuration files are imported into the software, you may set \verb+breakLoopType+=0 for two individual inversions, which ensures that the iteration loop of one inversion will not be affected by another inversion. If you set \verb+breakLoopType+=1 for joint inversion, then the iteration loop will be broken when one of the inversions satisfies its abort criterion. \verb+breakLoopType+= 2 means the iteration loop can be broken only if both the two abort criteria are satisfied. By setting \verb+saveCrossGradientMisfit+=1, one can calculate and save the cross gradient misfit in the log file. If \verb+inversionType+=1, the saved cross gradient misfit is related to the inner structural similarity of individual FWI, such as that of the S-wave velocity and density in SH FWI. If \verb+inversionType+=2, the saved cross gradient misfit is related to the outer structural similarity of JSI, such as that of the S-wave velocity and permittivity in JSI of SH-wave data and TM-wave data.

\subsubsection{Misfit}
The misfit definition has to be specified with the parameter \verb+misfitType+ which is shown together with other parameters in table \ref{tab:config_general_inversion_setting}. Currently, the single misfit type of L2 (L2 norm), L3 (convolution based), L4 (FK), L5 (envelope-weighted), L6 (AGC-weighted), L7 (normalized), L8 (envelope) and L9 (instantaneous phase) are available. One can choose multi-misfit type with the combination of several single misfit types. For example, by setting \verb+misfitType+ = L2781, the program randomly choose one of L2, L7 and L8 as a misfit function for each shot or, by setting \verb+misfitType+ = L2782, the program choose the one which can produce maximum relative convergence as a misfit function for each shot. If the parameter \verb+misfitType+ is end by ``1'', a random misfit waveform inversion (RMWI) is implemented. If the parameter \verb+misfitType+ is end by ``2'', an optimal misfit waveform inversion (OMWI) is implemented. Even if you set \verb+misfitType+ = L2 in a single misfit inversion, you can calculate multi misfits by setting \verb+multiMisfitType+ = L278 (little different with \verb+misfitType+) and output them by setting \verb+saveMultiMisfits+ = 1. \verb+multiMisfitType+ and \verb+saveMultiMisfits+ would be useful when you want to compare the performance of single misfit function and multi-misfit function. In inversion, one can set \verb+useRandomSource+ = 1 to randomly choose or set \verb+useRandomSource+ = 2 to sequentially choose \verb+NumShotDomains+ shots at each iteration, which will significantly speed up the inversion progress. The file \verb+logFilename(1:end-4).randomSource.log+ is used to output the source numbers selected in random shot inversion \verb+useRandomSource+ = 1 or sequential shot inversion \verb+useRandomSource+ = 2. Here, we show an example of random shot inversion with \verb+useRandomSource+ = 1, \verb+NumShotDomains+ = 3 and 6 shots in total:
\begin{verbatim}
# ShotNumber records during inversion
# random source type = 1 (0=all sequential shot,
# 1=numShotDomains random shot, 2=numShotDomains sequential shot)
# Stage | Iteration | shotNumbers
    1         1        3   5   0
    1         2        3   4   5
\end{verbatim}
If \verb+misfitType+ = L2781, then file \verb+logFilename(1:end-4).misfitType.log+ will be called to output the misfit type records during the random misfit inversion. Another file \verb+logFilename(1:end-4).L278.log+ is automatically created to store the misfit values of L2, L7 and L8 if \verb+multiMisfitType+ = L278 and \verb+saveMultiMisfitType+ = 1. Two examples are shown as below:
\begin{verbatim}
# MisfitType records during inversion
# Misfit type = L2781
# Stage | Iteration | misfitTypes
    1         1       7  7  2
    1         2       7  2  8
\end{verbatim}
\begin{verbatim}
# Misfit records during inversion
# misfit type = L2781
# Stage | Iteration |       2     |       7     |       8      
    1         1       9.98439e-09   2.24685e-05   7.61904e-09
    1         2      9.286833e-09  1.975601e-05  7.206325e-09
\end{verbatim}
Of course \verb+misfitType+ and \verb+useRandomSource+ are independent. So you can implement the random objective waveform inversion (ROWI) \citep{pan2020random} by setting \verb+misfitType+ = L2781, \verb+useRandomSource+ = 1 and \verb+NumShotDomains+ = 1, or implement the ROWI with shot parallelization by setting \verb+misfitType+ = L2781, \verb+useRandomSource+ = 1 and \verb+NumShotDomains+ > 1, or set \verb+useRandomSource+ = 1 to implement random source inversion with the same misfit function, or set \verb+misfitType+ = L2781 to implement random misfit inversion with all shots (\verb+useRandomSource+ = 0) or sequential shots with shot interval of numshots/numShotDomains (\verb+useRandomSource+ = 2) or sequential shots with shot interval of 1 (\verb+useRandomSource+ = 3), where numshots is the number of shots.

Similar with \verb+useRandomSource+, one can speed up the inversion by encoded source FWI \citep{krebs2009fast}. \verb+useSourceEncode+ = 1 selects the sources randomly \verb+useSourceEncode+ = 2 selects the sources sequentially with shot interval of numshots/numShotDomains, and \verb+useSourceEncode+ = 3 selects the sources sequentially with shot interval of 1 when encoding them to \verb+NumShotDomains+ supershots. Considering that seismic and GPR data acquisition may not be fix-spreading, we use frequency selection strategy \citep{huang2012multisource,zhang2018hybrid,zhang2019elastic} to decode the wavefields generated by the encoded source, which may compromise the speedup. One can use FFT (\verb+gradientDomain+ = 1) or DFT (\verb+gradientDomain+ = 2) or phase sensitive detection (PSD, \cite{nihei2007frequency})(\verb+gradientDomain+ = 3) to compute gradient in the frequency domain, limited by the number of selected frequency samples. Please note that \verb+useSourceEncode+ is not compatible with \verb+useRandomSource+.

Note that seismograms can be normalized for the calculation of the misfit and the adjoint sources by setting \verb+normalizeTraces+=1. This option is recommended for seismic field data. The parameter \verb+gradientKernel+ can be used to perform reflection waveform inversion \citep{xu2012inversion} or reverse time migration (RTM). One can use migration kernel alone (\verb+gradientKernel+=1) or tomographic kernel alone (\verb+gradientKernel+=2) or these two kernels interactively in inversion iteration (\verb+gradientKernel+=3). If \verb+gradientKernel+=4, RTM will be implemented once at the end of each workflow stage, which is related to the imaging condition controlled by \verb+misfitType+. If \verb+decomposition+=0, these kernels are computed using the Born approximation \citep{yao2017reflection}. If \verb+decomposition+$>$0, Poynting vector method is used for kernel computation \citep{tang2013tomographically}. If \verb+compensation+=1, the forward wavefield and back-propagated wavefield can be compensated in GPR FWI for the energy loss caused by electric conductivity.
The parameter \verb+DTInversion+ (default=1) defines the factor of \verb+DT+ for the cross-correlation in the gradient calculation. If e.g., it is set to 2, the maximum skipping time step satisfying Nyquist sampling principle is used to save computation time and wavefield storage. In case of \verb+gradientDomain+ != 0, the maximum skipping time step will be a power of 2 to ensure FFT.
The parameter \verb+DHInversion+ (default=1) defines the factor of \verb+DH+ for the cross-correlation in the gradient calculation. If e.g., it is set to 2, every second model space sample is picked on each direction, consequently, 1/4 or 1/8 memory is called in 2D or 3D waveform inversion. The highest possible value depends on the model resolution you want to obtain.

\subsubsection{Optimization}
Currently, there are two different optimization methods available, the steepest descent and the conjugate gradient method. Both can be used with gradient preconditioning (see subsection \ref{config:precond}). The method has to be chosen with the parameter \verb+optimizationType+. Possible values are \verb+steepestDescent+ and \verb+conjugateGradient+. The characters are internally transformed to lowercase letters, so \verb+STEEPESTDESCENT+ would also be valid.

The conjugate gradient direction at iteration $k$, $c^k$, is calculated in the following way:
\begin{equation*}
 c^k =  \nabla_{\vec{m}} \Phi^k + \beta^k \cdot c^{k-1}
\end{equation*}

The weight, $\beta^k$, is calculated after Polak and Ribi\'{e}re:
\begin{equation*}
 \beta^k_{\mathrm{PR}} = \frac{ \nabla_{\vec{m}}^T \Phi^k (\nabla_{\vec{m}} \Phi^k - \nabla_{\vec{m}} \Phi^{k-1}) }{\nabla_{\vec{m}}^T \Phi^{k-1} \nabla_{\vec{m}} \Phi^{k-1}}
\end{equation*}

Note that a steepest descent update is performed in the first iteration of every workflow stage.

The L-BFGS and the truncated Newton method are in developing and not available currently.

\subsubsection{Workflow file}
Additional to the configuration file a workflow file has to be used because some parameters are only defined there and are not available in the configuration file! The name is set by the parameter \verb+workflowFilename+. At the moment, the seismic workflow file contains the following parameters: \verb+invertForVp+, \verb+invertForVs+, \verb+invertForDensity+, \verb+invertForPorosity+, \verb+invertForSaturation+, \verb+relativeMisfitChange+, \verb+filterOrder+, \verb+lowerCornerFreq+, \verb+upperCornerFreq+ and \verb+timeDampingFactor+. Its structure is 
\begin{verbnobox}[\fontsize{11pt}{11pt}\selectfont]
#invertForVp invertForVs invertForDensity invertForPorosity invertForSaturation
      1           1            0                0                 0
      0           1            1                0                 0
      1           0            1                0                 0
\end{verbnobox}
\begin{verbnobox}[\fontsize{11pt}{11pt}\selectfont]
... relativeMisfitChange filterOrder lowerCornerFreq(Hz) upperCornerFreq(Hz)
             0.05            4             5                   20
             0.02            4             5                   40
             0.01            4             5                   60
\end{verbnobox}
\begin{verbnobox}[\fontsize{11pt}{11pt}\selectfont]
... timeDampingFactor
         5  
         0
        -5
\end{verbnobox}
With the first three parameters it can be decided which seismic parameter class should be updated. The parameter \verb+invertForPorosity+ and \verb+invertForSaturation+ are available for porosity and saturation update in petrophysical inversion where \verb+parametersation+=1 or 2. \verb+relativeMisfitChange+ will be explained in subsection \ref{config:abort} and the next three parameters are related to the frequency filtering which is documented in the manual of WAVE-Simulation (insert link). The last parameter \verb+timeDampingFactor+ is for time-frequency windowing \citep{athanasopoulos2020time}. For example, in shallow seismic FWI, you may start with the contribution of refracted P-waves and gradually increase the time window by decreasing \verb+timeDampingFactor+ to account for scattered body waves, higher mode Rayleigh waves and finally the fundamental Rayleigh wave mode. \verb+timeDampingFactor+ > 0 means the short travel time signals will be enhanced, while \verb+timeDampingFactor+ < 0 means the long travel time signals will be enhanced.

The GPR workflow file contains the following parameters: \verb+invertForSigma+, \verb+invertForEpsilon+, \verb+invertForTauSigma+, \verb+invertForTauEpsilon+, \verb+invertForPorosity+, \verb+invertForSaturation+, \verb+relativeMisfitChange+, \verb+filterOrder+, \verb+lowerCornerFreq+, \verb+upperCornerFreq+ and \verb+timeDampingFactor+. Its structure is 
\begin{verbnobox}[\fontsize{11pt}{11pt}\selectfont]
invertForSigma invertForEpsilon invertForTauSigma invertForTauEpsilon
      1                1                  0                   0                 
      0                1                  1                   0                 
      1                0                  1                   0                 
\end{verbnobox}
\begin{verbnobox}[\fontsize{11pt}{11pt}\selectfont]
... invertForPorosity invertForSaturation relativeMisfitChange filterOrder 
          0                 0                      0.05            4
          0                 0                      0.02            4
          0                 0                      0.01            4
\end{verbnobox}
\begin{verbnobox}[\fontsize{11pt}{11pt}\selectfont]
... lowerCornerFreq(Hz) upperCornerFreq(Hz) timeDampingFactor
         5e6                 20e6                5  
         5e6                 40e6                0
         5e6                 60e6               -5
\end{verbnobox}
With the first four parameters it can be decided which GPR parameter class should be updated. The next seven parameters are the same as that defined in seismic workflow.

\subsubsection{Parameterisation and regularization}
Parameter \verb+parametersation+ specifies a type of parametersation with 0 = modulus parametersation ($\lambda$, $\mu$, $\rho$ in seismic inversion and $\varepsilon$, $\sigma$ in GPR inversion), 1 = petrophysical parametersation in which petrophysical parameters are estimated by S-wave modulus in seismic inversion or by permittivity in GPR inversion, 2 = petrophysical parametersation in which petrophysical parameters are estimated by seismic modulus and density in seismic inversion or by permittivity and conductivity in GPR inversion, 3 = velocity parameterisation in seismic inversion or sqrt the reciprocal in GPR inversion ($v=1/\sqrt{\mu_m \varepsilon}$ and $\widetilde{\sigma}=1/\sqrt{\sigma}$), 4 = the modified logarithmic parameterisation in GPR inversion. Gassmann equation, Archie's equation and the complex refractive index model (CRIM) are employed in petrophysical parametersation, please see details in \cite{qin2022indirect}. When \verb+parametersation+ = 0 or 3 or 4 is set, you should only use the seismic parameter class in \verb+workflowFilename+. In JPI, that would lead to indirect petrophysical parameterisation  that porosity will be estimated by the updated seismic parameters while saturation is unchanged in seismic inversion, or saturation will be estimated by the updated GPR parameters while porosity is unchanged in GPR inversion. On the contrast, if you choose \verb+parametersation+ = 1 or 2, then you should only use the petrophysical parameter class in \verb+workflowFilename+. In JPI, that would lead to direct petrophysical parameterisation that the seismic parameters or GPR parameters will be calculated from the updated petrophysical parameters. Once you use the petrophysical relationships in GPR inversion, you have to define Archie coefficients \verb+aArchie+, \verb+mArchie+ and \verb+nArchie+ in order to link conductivity with porosity and saturation. In viscoelastic FWI and dispersive GPR FWI (viscotmem and viscoemem), one needs to set \verb+effectiveParameterisation+ for static parameter inversion (default=0) or effective parameter inversion (=1) \citep{qin2022full}.

Parameter \verb+stablizingFunctionalType+ specifies a type of regularization with 0 = no regularization applied, 1 = arctangent(AT) functional, 2 = minimum support (MS) functional \citep{hu2017traveltime}. If \verb+stablizingFunctionalType+ $\neq$ 0, \verb+focusingParameter+ has to be set to ensure the stability of regularization.

\subsubsection{Abort criterion}\label{config:abort}
Currently, there are three abort criteria implemented. The first criterion determines the maximum iteration number per workflow stage which can be set with the parameter \verb+maxIterations+. The second criterion measures the relative misfit change, $\Delta \Phi$, between the current iteration and the second last iteration:

\begin{equation*}
 \Delta \Phi = \frac{\Phi^k-\Phi^{k-2}}{\Phi^{k-2}}
\end{equation*}

If the absolute value of $\Delta \Phi$ is smaller than \verb+relativeMisfitChange+ the workflow stage is changed or - if it is the last stage - the inversion stops. The third criterion is that the value of $\Delta \Phi$ should be smaller than twice \verb+relativeMisfitChange+ to avoid a sharp increase in data misfit.

\subsection{Step length estimation}
\begin{table}[h!]
\caption[List of step length estimation configuration parameters.]{List of step length estimation configuration parameters, that can be added and changed in the config-file.}\label{tab:config_steplength}
\centering
\begin{adjustbox}{width=1\textwidth,center=\textwidth}
	\begin{tabular}{llll}
	\toprule
         Variable                 & Short description                                                   & Type   & Example value \\
	\midrule
         steplengthType           & Type of steplength (1 = line fit, 2 = parabolic fit)      & int & 2  \\
         steplengthInit           & Initial step length used in the first iteration of each stage       & double & 0.03  \\
         steplengthMin            & Minimum step length                                                 & double & 0.001 \\
         steplengthMax            & Maximum step length                                                 & double & 0.1 \\                     
         maxStepCalc              & Maximum number of additional step length calculations               &  int   & 4 \\                         
         scalingFactor            & Factor for multiplication or division of test step length           & double & 2.0 \\                                            
         testShotIncr             & Increment of test shots                                             &  int   & 1 \\                       
	\bottomrule
	\end{tabular}
	\end{adjustbox}
\end{table}
For gradient-based, local optimization algorithms usually a step length estimation is necessary. In the case the steepest descent or conjugate gradient method is used (with or without preconditioning), WAVE-Inversion performs an inexact line search using a line fit (\verb+steplengthType+=1) parabolic fit (\verb+steplengthType+=2) of the misfit function. For the parabolic fit three step length/misfit pairs are used. To save computation time the first pair is given by the step length zero and the misfit of the current model. The second pair is given by the parameter \verb+steplengthInit+ and the misfit calculated from the updated model with \verb+steplengthInit+, both shown together with other parameters in table \ref{tab:config_steplength}. For the third pair two cases are distinguished: 1) if the misfit was decreased, the step length is multiplied with the parameter \verb+scalingFactor+ and a third step length is searched which gives a larger misfit than the second step length. If the misfit is still decreasing, the step length will again be multiplied with \verb+scalingFactor+ until it increases or the parameter \verb+maxStepCalc+ is reached. 2) If the misfit was increased, the step length is divided by the parameter \verb+scalingFactor+ and a third step length is searched which gives a smaller misfit than the first step length. If the misfit is too large, the step length will again be divided by \verb+scalingFactor+ until it sufficiently decreases or the parameter \verb+maxStepCalc+ is reached.
Note that the parameter \verb+steplengthInit+ is decreased by 2 \% after each iteration within each workflow stage. The parameter is reset at the beginning of each stage to the value specified in the configuration file.
After calculating three step length/misfit pairs, four cases are distinguished to choose a proper step length:
\begin{enumerate}
 \item $\Phi^2$ < $\Phi^1 \land \Phi^3 > \Phi^2$: apply parabolic fit to find step length or use \verb+steplengthMax+ 
 \item $\Phi^2$ < $\Phi^1 \land \Phi^3 < \Phi^2$: use third step length or \verb+steplengthMax+
 \item $\Phi^2$ > $\Phi^1 \land \Phi^3 < \Phi^1$: use third step length 
 \item $\Phi^2$ > $\Phi^1 \land \Phi^3 > \Phi^1$: use \verb+steplengthMin+
\end{enumerate}

Here, $\Phi$ stands for misfit. Note that the parameter \verb+steplengthMax+ is used if the third step length (cases 1 and 2) exceeds the specified value.
To save computation time, the step length estimation can be performed with a subset of the sources. The sources that are used can be specified with the parameters \verb+testShotIncr+. It is incremented by \verb+testShotIncr+ from the first shot.

Currently it is only possible to use one common step length for all model parameter classes (P-wave velocity, S-wave velocity, etc.). In the case of steepest descent or conjugate gradient method (with or without preconditioning) the model is updated in the following ways
\begin{equation}
\label{eqn:scaleGradient1}
 \vec{m}^{k+1} = \vec{m}^k - \alpha \cdot \frac{\mathrm{max}(\vec{m}^k)}{\mathrm{max}(\nabla_{\vec{m}} \Phi^k)} \nabla_{\vec{m}} \Phi^k   
\end{equation}
\begin{equation}
\label{eqn:scaleGradient2}
 \vec{m}^{k+1} = \vec{m}^k - \alpha \cdot \frac{m_u-m_l}{\mathrm{max}(\nabla_{\vec{m}} \Phi^k)} \nabla_{\vec{m}} \Phi^k   
\end{equation}
with $k$ as iteration number and $\alpha$ as step length. Thus, a step length of 0.01 results in a maximum model update of 1 \% of the maximum of the corresponding model parameter if you set \verb+scaleGradient+ = 1 (equation \ref{eqn:scaleGradient1}), or 1 \% of the contrast between the upper model parameter limit $m_u$ and lower model parameter limit $m_l$ if you set \verb+scaleGradient+ = 2 (equation \ref{eqn:scaleGradient2}). The parameter \verb+scaleGradient+ is shown in table \ref{tab:config_precon}.

\subsection{Source time function inversion}
\begin{table}[h!]
\caption[List of source time function inversion configuration parameters.]{List of source time function inversion configuration parameters, that can be added and changed in the config-file.}\label{tab:config_sourcetime}
\centering
\begin{adjustbox}{width=1\textwidth,center=\textwidth}
	\begin{tabular}{llll}
	\toprule
         Variable                 & Short description                                                   & Type   & Example value \\
	\midrule
         useSourceSignalInversion & Use source time inversion (0, 1, 2)                                          &  int   & 0 (=no) \\
         waterLevel               & Water level of source time inversion                                & double & 0.01 \\
         writeInvertedSource      & Source signal will be written to disk                               &  int   & 1 (=yes) \\
         sourceSeismogramFilename & Filename-prefix of output source signal                               & string & seismograms/invSource \\
         useSourceSignalTaper     & Use cosine taper for source signal (0, 1, 2)                                  &  int   & 1 \\
         sourceSignalTaperStart1  & Start index of first cosine taper                                   &  int   & 0 \\
         sourceSignalTaperEnd1    & End index of first cosine taper                                     &  int   & 100 \\
         sourceSignalTaperStart2  & Start index of second cosine taper                                  &  int   & 0 (=no second taper) \\
         sourceSignalTaperEnd2    & End index of second cosine taper                                    &  int   & 0 \\
         minOffsetSrcEst          & Minimum offset in grid points to allow                              &  double   & 0 \\
         maxOffsetSrcEst          & Maximum offset in grid points to allow                              &  double   & 0 \\  
         mainVelocity          & Main velocity of the media                              &  double   & 0 \\
         useSeismogramTaper       & Use seismogram taper (0, 1, 2, 3, 4)               &  int   & 0 (=no) \\
         seismogramTaperName      & Filename-prefix of seismogram taper                                   & string & seismograms/seismoTaper \\
	\bottomrule
	\end{tabular}
	\end{adjustbox}
\end{table}
As the source that generates the observed data $d^{obs}$ is unknown, the source signature is unknown as well. By using the source time function (STF) inversion, the true source is approximated by a filtered synthetic one. Choosing the filter so that filtered synthetic source signature is as close to the real source signature leads to a minimized misfit function by L2 norm. The wanted result is 
\begin{equation*}
 s(w)=\dfrac{\vec{d}^T\vec{u}^*}{\vec{u}^T\vec{u}^*+\epsilon}
\end{equation*}
where $w$ is angular frequency. $\epsilon$ is added to stabilize the equation if the denominator is small and can be modified by the parameter \verb+waterLevel+ which is shown together with the other parameters in table \ref{tab:config_sourcetime}.  \verb+useSourceSignalInversion+=1 uses a synthetic signal defined by \verb+SourceFilename+ as a starting source. One can use the reference trace extracted from the field data instead by setting \verb+useSourceSignalInversion+=2, which should approximate the real source in shape. The source signature can be inverted at the first iteration of each workflow stage, used for one workflow stage and be written on the disk by \verb+writeInvertedSource+ with the location/name \verb+sourceSeismogramFilename+.

In addition, a cosine taper can be used for the source signal, e.g., at the beginning or end of it by the parameter \verb+useSourceSignalTaper+=1. The start and end indices can be selected by \verb+sourceSignalTaperStart1+ and \verb+sourceSignalTaperEnd1+ or if a second taper is needed by \verb+sourceSignalTaperStart2+ and \verb+sourceSignalTaperEnd2+. \verb+useSourceSignalTaper+=2 is to damp the inverted source signal automatically, i.e., using a cosine taper in the time one period (related to the middle frequency of each workflow stage) away from the peak signal. The parameters \verb+minOffsetSrcEst+ and \verb+maxOffsetSrcEst+ can be set in case of that you want to use special offset data for STF inversion, such as near-field data or far-field data. If \verb+mainVelocity+ is set, normal moveout (NMO) is applied to the traces selected by \verb+minOffsetSrcEst+ and \verb+maxOffsetSrcEst+ and a reference trace is obtained by averaging those traces.
A taper can also be used for the seismograms or radargrams by the parameter \verb+useSeismogramTaper+ and by specifying the location/name of it with \verb+seismogramTaperName.shot_<shot number>.mtx+. \verb+useSeismogramTaper+=1 represents this taper will be applied only for STF inversion, while \verb+useSeismogramTaper+=2 means this taper can be used only for data misfit calculation. \verb+useSeismogramTaper+=3 means the same taper can be used for both STF inversion and data misfit calculation.  On the contrast, \verb+useSeismogramTaper+=4 is used for that STF inversion and data misfit calculation use different tapers, that are,  \verb+seismogramTaperName.SrcEst.shot_<shot number>.mtx+ and \verb+seismogramTaperName.misfitCalc.shot_<shot number>.mtx+, respectively. By setting \verb+useSeismogramTaper+=5, the program will create a cosine taper automatically to mute the signal with the maximum amplitude, e.g., the air wave in surface-base GPR data. The combination of \verb+useSeismogramTaper+ and \verb+timeDampingFactor+ is recommended to select the signal in desired offset region and travel time region for offset-time-frequency windowing.

\subsection{Gradient preconditioning}
\label{config:precond}
\begin{table}[h!]
\caption[List of gradient preconditioning configuration parameters.]{List of gradient preconditioning configuration parameters, that can be added and changed in the config-file.}\label{tab:config_precon}
\centering
\begin{adjustbox}{width=1\textwidth,center=\textwidth}
	\begin{tabular}{llll}
	\toprule
         Variable                 & Short description                                                   & Type   & Example value \\
	\midrule
        sourceReceiverTaperType  &  \begin{tabular}{@{}l@{}}{Type of source and receiver tapers} \\{(1 = log, 2 = $\cos^2$, 3 = source-receiver, 4, 5)}\end{tabular}                  &  int   & 1 \\
         sourceTaperRadius        & Circular source taper: Radius in grid points                        &  int   & 20 \\ 
         receiverTaperRadius      & Circular receiver taper: Radius in grid points                      &  int   & 20 \\
         useGradientTaper         & Use a taper for the gradient                                        &  int   & 0 (=no) \\
         gradientTaperFilename    & Filename-prefix of the gradient taper                                 & string & \begin{tabular}{@{}l@{}}{gradients/} \\{gradientTaper}\end{tabular}   \\
         useEnergyPreconditioning & \begin{tabular}{@{}l@{}}{Approximated diagonal of Hessian is applied to} \\{ gradient per shot (0, 1, 2)}\end{tabular}    &  int   & 1 \\ 
         epsilonHessian           & \begin{tabular}{@{}l@{}}{Water level to stabilize matrix inversion } \\{(recommended: 0.005)}\end{tabular}       & double & 0.005 \\      
         saveApproxHessian        & Save approximated diagonal of Hessian                               &  int   & 0 (=no) \\
         approxHessianName        & Filename-prefix for approximated diagonal of Hessian                   & string & gradients/Hessian \\
         normalizeGradient        & Normalize gradient of each shot                                     &  int   & 0 (=no) \\
         scaleGradient        & Scale gradient of each shot (0, 1 and 2)                                     &  int   & 1 \\
         weightGradient        & Weight gradient of each shot (0, 1)                                    &  int   & 0 \\
         smoothGradient        & Smooth gradient (0, 11 and 21)                                     &  int   & 11 \\
	\bottomrule
	\end{tabular}
	\end{adjustbox}
\end{table}
Usually it is helpful to manipulate the gradient, e.g., to mitigate artifacts close to the source and receiver positions. There are currently three possibilities for gradient preconditioning: source and receiver tapers and energy preconditioning. A list of configurable parameters is shown in table \ref{tab:config_precon}.

Circular tapers around the source and receiver positions can be used by setting \verb+sourceTaperRadius+ > 0 and \verb+receiverTaperRadius+ > 0, respectively. The number corresponds to the radius of the taper in grid points. The taper is zero in the middle and increases to one at the outside of the circle. The increasing type is either logarithmic or cosine which can be chosen by setting the parameter \verb+sourceReceiverTaperType+ to either 1 or 2. If \verb+sourceReceiverTaperType+ = 3, one can apply a source-receiver taper for each shot in crosshole and VSP geometries to mitigate the artifacts between the left/right boundaries and sources/receivers. Thus only the gradient between source and receiver array is retained. \verb+sourceReceiverTaperType+ = 4 = 1 + 3 and \verb+sourceReceiverTaperType+ = 5 = 2 + 3 mean that both circular taper and source-receiver taper will be used.

Energy preconditioning can be used by setting \verb+useEnergyPreconditioning+ to 1. It is based on migration weight $K^{(1)}$ from \cite{plessix2004frequency} (see also \cite{shin2001improved}) which is the inverse of an approximation of the diagonal of the Hessian. This type of preconditioning has also the effect of mitigating source/receiver artifacts. Moreover, it increases model updates in less illuminated areas of the model and can improve the convergence behaviour of the inversion. It is calculated by squaring and adding all available velocity/electric wavefields summed over all time steps. The taper is calculated and applied for each shot separately. To stabilize the approximated Hessian a water level has to be set with the parameter \verb+epsilonHessian+. From experience, we recommend a value of 0.005. If \verb+useEnergyPreconditioning+ is set to 2, one can apply energy preconditioning to not only the source position but also the receiver position \citep{kurzmann2013acoustic}. Another preconditioning of equalizing the gradient in different location can be applied by setting \verb+useEnergyPreconditioning+ = 3 \citep{nuber2015enhancement}. Besides, the second preconditioning and the third preconditioning can be used simultaneously if you set \verb+useEnergyPreconditioning+ = 4.
The taper can be saved to disk with the file name \verb+approxHessianName+ by setting \verb+saveApproxHessian+ to 1.
In addition, the gradient can be normalized for each shot by setting \verb+normalizeGradient+ to 1.
As discussed previously, the gradient can be scaled to the maximum of the corresponding model parameter if you set \verb+scaleGradient+ = 1, or to the contrast between the upper model parameter limit $m_u$ and lower model parameter limit $m_l$ if you set \verb+scaleGradient+ = 2. The parameter \verb+weightGradient+ can be used in stream configuration where each shot covers different region. \verb+weightGradient+=0 means equal weight for the gradient of different shots, while \verb+weightGradient+=1 means that we add more weight on the gradient of higher absolute values in $x$-direction. To mitigate the artifacts smaller than the size of mean wavelength, we use a 2D Gaussian filter on gradient. The parameter \verb+smoothGradient+=11 means the 1D Gaussian filter (the first 1) is applied in $x$-direction with one mean wavelength (the second 1) as the filter size. \verb+smoothGradient+=21 means the 2D Gaussian filter (the first 2) with the same filter size (the second 1) is used. The second value in \verb+smoothGradient+ can be set greater than 1 if you want to apply stronger smooth but with lower resolution. Please note that greater filter size means that longer time is needed to initialize the Gaussian kernel before the inversion starts.

\subsection{Model thresholds}
\label{config:precond}
\begin{table}[h!]
\caption[List of model thresholds configuration parameters.]{List of model thresholds configuration parameters, that can be added and changed in the config-file.}\label{tab:config_thresholds}
\centering
\begin{adjustbox}{width=1\textwidth,center=\textwidth}
	\begin{tabular}{llll}
	\toprule
         Variable                 & Short description                                                   & Type   & Example value \\
	\midrule
         useModelThresholds     & Use thresholds for model parameters                                 &  int   & 1 (=yes) \\
         lowerVpVsRatioTh                & Lower vp-vs ratio threshold, must be > sqrt(2.0)              & double & 1.5 \\
         upperVpVsRatioTh                & Upper vp-vs ratio threshold                        & double & 3.0 \\
         lowerVPTh                & Lower vp threshold in meter per seconds                             & double & 1481 \\
         upperVPTh                & Upper vp threshold in meter per seconds                             & double & 6000 \\
         lowerVSTh                & Lower vs threshold in meter per seconds                             & double & 700 \\
         upperVSTh                & Lower vs threshold in meter per seconds                             & double & 3500 \\
         lowerDensityTh           & Lower density threshold in kilogramms per cubicmeter                 & double & 1000 \\
         upperDensityTh           & Upper density threshold in kilogramms per cubicmeter                 & double & 5000 \\
         lowerSigmaTh           & Lower conductivity threshold in S/m                 & double & 1e-3 \\
         upperSigmaTh           & Upper conductivity threshold in S/m                 & double & 10e-3 \\
         lowerEpsilonrTh           & Lower relative permittivity threshold in (-)                & double & 5 \\
         upperEpsilonrTh           & Upper relative permittivity threshold in (-)                 & double & 20 \\
         lowerTauSigmarTh           & Lower tauEpsilon threshold in (-)                 & double & 0 \\
         upperTauSigmarTh           & Upper tauEpsilon threshold in (-)                & double & 5 \\
         lowerTauEpsilonTh           & Lower tauEpsilon threshold in (-)                 & double & 0 \\
         upperTauEpsilonTh           & Upper tauEpsilon threshold in (-)                 & double & 0.5 \\
         lowerPorosityTh           & Lower porosity threshold in (-)                 & double & 0.05 \\
         upperPorosityTh           & Upper porosity threshold in (-)                 & double & 0.35 \\
         lowerSaturationTh           & Lower saturation threshold in (-)                 & double & 0.10 \\
         upperSaturationTh           & Upper saturation threshold in (-)                 & double & 0.70 \\
	\bottomrule
	\end{tabular}
	\end{adjustbox}
\end{table}
For seismic inversion, the lower and upper limit of the model parameters as seen in table \ref{tab:config_thresholds} can be definied in meter per second or kilogram per cubicmeter for P-wave and S-wave velocity and density, respectively. Specially, for elastic and viscoelastic equation, one can set the lower and upper limit for P-wave and S-wave velocity ratio which should be greater than $\sqrt{2}$ because $v_p=\sqrt{(\lambda+2\mu)/\rho}$ and $v_s=\sqrt{\mu/\rho}$ where $\lambda$ > 0.

For GPR inversion, one can set the lower and upper limits for conductivity $\sigma$, relative permittivity $\varepsilon_r$, $\tau_{\sigma e r}$ and $\tau_{\varepsilon}$ where $\tau_{\sigma e r}=\tau_{\sigma e}/\tau_{D}=2 \pi f_l \tau_{\sigma e}$ and $f_l$ is the relaxation frequency of the $l$th relaxation mechanism (see details in \cite{qin2022full}). Due to that conductivity and permittivity are constant in air and water ($\sigma$ = 0, $\varepsilon_r$ = 1 in air and $\varepsilon_r$ = 81 in water), air and water area will be automatically excluded from the the defined model thresholds. For example, if your model includes an air layer above the ground where the transmitters and receivers are laid out for surface GPR FWI, \verb+lowerEpsilonrTh+ = 5 in table \ref{tab:config_thresholds} will only be applied to the underground area of your model.

In petrophysical inversion, the lower and upper limit of porosity and saturation have to be defined with \verb+lowerPorosityTh+ > 0.0, \verb+lowerPorosityTh+ > 0.0, \verb+upperPorosityTh+ < $\phi_c$ and \verb+upperPorosityTh+ < 1.0 where $\phi_c=0.4$ is the critical porosity above which the solid becomes a suspension. 

\clearpage
\section{Pre- and Post-Processing}\label{sec:process}

As already mentioned in section \ref{sec:config}, data can be read from a single file as well as from a partitioned file-block. The advantage of a distributed file system ist, that CPUs/GPUs can read data simultaneously and therefore with substantial timesaving. Installing LAMA with all examples (\shellcmd{-DBUILD\_EXAMPLES=ON}), LAMA includes examples to partition and repartition files or file-blocks in \shellcmd{.mtx}-format (\shellcmd{vectorRepartition.exe}). 

To partition a single vector-file change to the directory where the files are located and run the following comand:  \\
\shellcmdline{\$SCAI\_ROOT/lama/examples/io/vectorRepartition.exe filename.mtx 1 }\\
\shellcmdline{filename\_\%r.mtx <NProcessors>}\\
The first part marks the LAMA-example to repartition a file, \shellcmd{filename.mtx} is a single file (\shellcmd{1}) you want to partition and \shellcmd{filename\_\%r.mtx} is the name of the output file-block. The number of files in a file-block has to be the same as the number of CPUs/GPUs (\shellcmd{<NProcessors>}) reading the file-block later on. 

To merge a fileblock \shellcmd{filename\_\%r.mtx} to a single vector-file, the command is very similar:\\
\shellcmdline{\$SCAI\_ROOT/lama/examples/io/vectorRepartition.exe filename\_\%r.mtx}\\
\shellcmdline{<NProcessors> filename.mtx 1}\\
In this case the name of the file-block and its size is written first and then the name of the single output-file.

\section{Unit Tests}
To guarantee a functioning framework, WAVE-Inversion includes unit-tests using the googletest framework. To run all unit-tests, you first have to install googletest (e.g., from \url{http://code.google.com/p/googletest}). 

As preparatory steps environment variables have to be linked to googletest. Add the following lines to the \shellcmd{{\char`\~}/.bashrc}:
\\\shellcmdline{ `export GTEST\_DIR=[PATH\_TO\_GTEST\_DIRECTORY]`}
\\\shellcmdline{ `export LD\_LIBRARY\_PATH=\$\{GTEST\_DIR\}:\$\{LD\_LIBRARY\_PATH\}`}
\\\shellcmdline{ `export DYLD\_LIBRARY\_PATH=\$\{GTEST\_DIR\}:\$\{DYLD\_LIBRARY\_PATH\}}

To compile all tests, change the directory: \\\shellcmdline{/src/} \\ and compile the tests by simply entering:\\\shellcmdline{make utest} and \shellcmdline{make itest}

The executable file is located in the directory:
\\\shellcmdline{/build/bin}\\
To execute the unit-tests change to the \shellcmd{/par} folder and run the \shellcmd{Test\_unit} file by entering:
\\\shellcmdline{./../bin/Tests/Test\_unit}\\ 
For faultless function of WAVE-Inversion all tests should execute without failure.

\section{Benchmark}

\cleardoublepage
\addtocontents{toc}{\protect\setcounter{tocdepth}{0}}
\listoffigures
\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\addcontentsline{toc}{chapter}{List of Figures}
\addtocontents{toc}{\protect\setcounter{tocdepth}{0}}
\listoftables
\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\addcontentsline{toc}{chapter}{List of Tables}
\cleardoublepage
% \bibliography{@CMAKE_SOURCE_DIR@/../doc/guide/WAVE_Inversion_guide.bib}
\bibliography{WAVE_Inversion_guide}
\bibliographystyle{apalike}

\appendix
\chapter{Acoustic wave}
\label{sec:Acoustic_wave_equation}
\section{Acoustic wave equation}
3D acoustic Wave Equation:
\begin{align}
\rho\pdv{v_x}{t}&=\pdv{p}{x} + f_x\\
\rho\pdv{v_y}{t}&=\pdv{p}{y} + f_y\\
\rho\pdv{v_z}{t}&=\pdv{p}{z} + f_z\\
\frac{1}{\lambda}\pdv{p}{t} &= \pdv{v_x}{x} +  \pdv{v_y}{y} + \pdv{v_z}{z} + \frac{1}{\lambda}\pdv{p_0}{t}
\end{align}
Matrix formulation of forward problem:
\begin{equation}
 M\left( \pdv{}{t}\mathbf{u}-\mathbf{s} \right) =Q\mathbf{u}
\end{equation}
\begin{equation}
\mathbf{u}=\left(v_x,v_y,v_z,p \right)^T
\end{equation}
\begin{equation}
\mathbf{s}=\left(\frac{f_x}{\rho},\frac{f_y}{\rho},\frac{f_z}{\rho},\pdv{p_0}{t}\right)^T
\end{equation}
\begin{equation}
Q=
 \begin{pmatrix}
   0         & 0         & 0         & \pdv{}{x}\\
   0         & 0         & 0         & \pdv{}{y}\\
   0         & 0         & 0         & \pdv{}{z}\\
   \pdv{}{x} & \pdv{}{y} & \pdv{}{z} & 0        
 \end{pmatrix}, \quad Q^{*} = -Q
\end{equation}
\begin{equation}
M=
 \begin{pmatrix}
   \rho       & 0         & 0         & 0                \\
   0          & \rho      & 0         & 0                \\
   0          & 0         & \rho      & 0                \\
   0          & 0         & 0         & \frac{1}{\lambda}
 \end{pmatrix}, \quad M^{*}=M
\end{equation}

\section{Gradient}
Adjoint state equation
\begin{equation}
\label{eqn:AdjointEquation111}
\mathbf{u}_{1}^{’}:
\begin{cases}
\rho\pdv{v_{1i}^{’}}{t^{'}}=\pdv{p^{’}}{x_j} + R^{*}(R v_i -v_i^{obs})\\
\pdv{p^{’}}{t^{'}} = \lambda \pdv{v_{1k}^{’}}{x_k} - \pdv{R^{*}(R p - p^{obs})}{t^{'}}
\end{cases}
\end{equation}
\begin{equation}
\begin{align}
&\mathbf{u}_{1}^{’} = \varLambda \mathbf{u}_{1} = \left(v_{1x}^{’},v_{1y}^{’},v_{1z}^{’},p^{’}\right)^T \\
&\mathbf{u}_{1} = \varLambda \mathbf{u}_{1}^{’}, \quad diag(\varLambda) = \left(1,1,1,-1 \right)
\end{align}
\end{equation}
where $t^{'}=T-t$ (the reversed time).\\
The gradient in compact form:
\begin{equation}
 \pdv{\Phi_1}{m}=-\int_0^T (\varLambda \mathbf{u}_{1}^{’})^{*} \pdv{M}{m}\left( \pdv{}{t}\mathbf{u}-\mathbf{s} \right)dt
\end{equation}
Gradient in details:
\begin{align}
 \pdv{\Phi_1}{\rho}&= -\int_0^T \left( \pdv{v_x}{t} v_{1x}^{’} + \pdv{v_y}{t} v_{1y}^{’} + \pdv{v_z}{t} v_{1z}^{’} \right) dt\\
 \pdv{\Phi_1}{\lambda}&=- \frac{1}{\lambda^2}\int_0^T  \pdv{p}{t}p_1^{’} dt \\
\end{align}

\chapter{EM wave}
\label{sec:EM_wave_equation}
\section{EM wave equation}
\par Maxwell equations including constitutive relations is shown as two rotation equations: \\
\begin{equation}
\begin{aligned}
\label{eqn:MaxwellEquation}
&-\mu_{m} \pdv{ \mathbf{H}}{t} - \sigma_{m}\mathbf{H} - \nabla \times \mathbf{E} =  \mathbf{J_{m}} \\
&\varepsilon\pdv{ \mathbf{E}}{t} + \sigma\mathbf{E} -\nabla \times \mathbf{H} =  - \mathbf{J_{e}}
\end{aligned}
\end{equation}
where $\sigma$, $\sigma_{m}$, $\varepsilon$ and $\mu_{m}$ are the electric conductivity, magnetic conductivity, dielectric permittivity and magnetic permeability. $\mathbf{J_{e}}$ and $\mathbf{J_{m}}$ are the electric and magnetic current sources. $\mathbf{H}$ and $\mathbf{E}$ are the magnetic intensity field tensor and electric intensity field tensor in Maxwell equations which explain the physical mechanism of electromagnetic (EM) wave propagation.\\
\par 3D EM Wave Equation in anisotropic media:
\begin{equation}
\begin{aligned}
\label{eqn:MaxwellEquation1}
&-\mu_{mx} \pdv{H_{x}}{t} - \sigma_{mx} H_{x} - (\pdv{E_z}{y} - \pdv{E_y}{z}) = J_{mx}\\
&-\mu_{my} \pdv{H_{y}}{t} - \sigma_{my} H_{y} - (\pdv{E_x}{z} - \pdv{E_z}{x}) = J_{my}\\
&-\mu_{mz} \pdv{H_{z}}{t} - \sigma_{mz} H_{z} - (\pdv{E_y}{x} - \pdv{E_x}{y}) = J_{mz}\\
&\varepsilon_{x} \pdv{E_{x}}{t} + \sigma_{x} E_{x} - (\pdv{H_z}{y} - \pdv{H_y}{z}) = -J_{ex}\\
&\varepsilon_{y} \pdv{E_{y}}{t} + \sigma_{y} E_{y} - (\pdv{H_x}{z} - \pdv{H_z}{x}) = -J_{ey}\\
&\varepsilon_{z} \pdv{E_{z}}{t} + \sigma_{z} E_{z} - (\pdv{H_y}{x} - \pdv{H_x}{y}) = -J_{ez}
\end{aligned}
\end{equation}
\par We rewrite the Eq.\ref{eqn:MaxwellEquation1} as:
\begin{equation}
\begin{aligned}
\label{eqn:MaxwellEquationMatrix}
&M_1 \partial_{t} \mathbf{u} + M_2 \mathbf{u} - Q\mathbf{u} = \mathbf{s} \\
&\mathbf{u} = (\mathbf{H}, \mathbf{E})^T, \mathbf{s} = (\mathbf{J_{m}}, -\mathbf{J_{e}})^T \\
\end{aligned}
\end{equation}
\begin{equation}
\begin{aligned}
\begin{split}
& M_1 =
 \begin{pmatrix}
   -\mu_{mx}       & 0         & 0         & 0         & 0         & 0       \\
   0          & -\mu_{my}      & 0         & 0         & 0         & 0        \\
   0          & 0         & -\mu_{mx}      & 0         & 0         & 0        \\
   0          & 0         & 0         & \varepsilon_{x}      & 0         & 0        \\
   0          & 0         & 0         & 0         & \varepsilon_{y}      & 0        \\
   0          & 0         & 0         & 0         & 0         & \varepsilon_{z}     \\
 \end{pmatrix}, 
 M_2 =
 \begin{pmatrix}
   -\sigma_{mx}       & 0         & 0         & 0         & 0         & 0       \\
   0          & -\sigma_{my}      & 0         & 0         & 0         & 0        \\
   0          & 0         & -\sigma_{mz}      & 0         & 0         & 0        \\
   0          & 0         & 0         & \sigma_{x}      & 0         & 0        \\
   0          & 0         & 0         & 0         & \sigma_{y}      & 0        \\
   0          & 0         & 0         & 0         & 0         & \sigma_{z}     \\
 \end{pmatrix} \\
& Q = 
 \begin{pmatrix}
   0          & 0         & 0         & 0 	  	& -\partial_{z}	& \partial_{y}   \\
   0          & 0         & 0         & \partial_{z} 	& 0 	      	& -\partial_{x}  \\
   0          & 0         & 0         & -\partial_{y}	& \partial_{x} 	& 0	      \\
   0 	  	& -\partial_{z}	& \partial_{y}        & 0         & 0         & 0        \\
   \partial_{z} 	& 0 	      	& -\partial_{x}       & 0 	       & 0         & 0        \\
   -\partial_{y}	& \partial_{x} 	& 0         	   & 0	       & 0         & 0        \\
 \end{pmatrix} = 
 \begin{pmatrix}
   0          & D         \\
   D          & 0         \\
 \end{pmatrix} = 
 \begin{pmatrix}
   0          & D_i \partial_{i}         \\
   D_i \partial_{i}          & 0         \\
 \end{pmatrix}, \quad Q^{*}=Q \\
& D_1= 
 \begin{pmatrix}
   0          & 0        & 0 \\
   0          & 0        & -1 \\
   0          & 1        & 0 
 \end{pmatrix},  D_2= 
 \begin{pmatrix}
   0          & 0        & 1 \\
   0          & 0        & 0 \\
  -1          & 0        & 0 
 \end{pmatrix},
  D_3= 
 \begin{pmatrix}
   0          & -1        & 0 \\
   1          & 0        & 0 \\
   0          & 0        & 0 
 \end{pmatrix} ,
 D_i^{*} = D_i^T = -D_i\\
\end{split}
\end{aligned}
\end{equation}
$^{*}$ is the transpose conjugate operation. $\partial_{1} = \partial_{x}$, $\partial_{2} = \partial_{y}$, $\partial_{3} = \partial_{z}$.\\

\section{1st order adjoint method}
\par The misfit function
\begin{equation}
 \Phi_1(\mathbf{m}) = \Phi_1(\mathbf{u}) = \frac{1}{2} || \mathbf{d}^{syn}(\mathbf{m}) - \mathbf{d}^{obs} ||_2^2 = \frac{1}{2} || R\mathbf{u}(\mathbf{m}) - \mathbf{d}^{obs} ||_2^2 \\
\end{equation}
where the synthetic data $\mathbf{d}^{syn}$ is extracted by the restriction operator $R$ from the synthetic wavefield $\mathbf{u}$. $\mathbf{d}^{obs}=(\mathbf{H}^{obs}, \mathbf{E}^{obs})$. \\
\par Augmented functional used in 1st order adjoint method:
\begin{equation}
 L_1(\mathbf{m}, \mathbf{u},\mathbf{u}_{1}) = \Phi_1(\mathbf{u}) + \langle \mathbf{u}_{1}, F(\mathbf{u},\mathbf{m}) \rangle_W \\
\end{equation}
with
\begin{equation}
\begin{split}
\label{eqn:initialCondition1}
 & F(\mathbf{u},\mathbf{m}) = M_1 \partial_{t} \mathbf{u} + M_2 \mathbf{u} - Q\mathbf{u} - \mathbf{s} = 0 \\
 & \mathbf{m} = (\varepsilon, \sigma, \mu_m, \sigma_m)^T, \mathbf{u}|_{t=0} = 0, \mathbf{u}|_{x\in \partial \Omega} = 0
 \end{split}
\end{equation}
where the inner product $\langle \mathbf{h}_1, \mathbf{h}_2 \rangle_W$ in the domain $W=\Omega \times [0, T]$ is defined by ($\Omega$ is the spatial computation domain)\\
\begin{equation}
 \langle \mathbf{h}_1, \mathbf{h}_2 \rangle_W = \int_0^T \int_\Omega \mathbf{h}_1^{*}(x,t) \mathbf{h}_2(x,t) dt dx
\end{equation}
\par For any $\mathbf{u}_{1}$:
\begin{equation}
 L_1(\mathbf{m}, \mathbf{u},\mathbf{u}_{1}) = \Phi_1(\mathbf{u}) 
\end{equation}
\par We write the augmented functional explicitly:
\begin{equation}
\label{eqn:AugmentFunctional1}
 L_1(\mathbf{m}, \mathbf{u},\mathbf{u}_{1}) = \frac{1}{2} \int_0^T \int_\Omega (R\mathbf{u} - \mathbf{d}^{obs})^2 dt dx + \int_0^T \int_\Omega \mathbf{u}_{1}^{*} (M_1 \partial_{t} \mathbf{u} + M_2 \mathbf{u} - Q \mathbf{u} - \mathbf{s})  dt dx
\end{equation}
\par If the final condition and boundary condition of $\mathbf{u}_{1}$ are satisfied by:
\begin{equation}
\label{eqn:initialCondition2}
 \mathbf{u}_{1}|_{t=T} = 0, \mathbf{u}_{1}|_{x\in \partial \Omega} = 0
\end{equation}
\par Integration by parts and then we get:
\begin{equation}
\begin{split}
L_1(\mathbf{m}, \mathbf{u},\mathbf{u}_{1})
  &= \frac{1}{2} \int_0^T \int_\Omega (R\mathbf{u} - \mathbf{d}^{obs})^2 dt dx\\ &+ \int_0^T \int_\Omega [(-M_1 \partial_{t} \mathbf{u}_{1})^* \mathbf{u} + (M_2 \mathbf{u}_{1})^* \mathbf{u} - (Q \mathbf{u}_{1})^* \mathbf{u} - \mathbf{u}_{1}^* \mathbf{s} ] dt dx
 \end{split}
\end{equation}
where 
\begin{equation}
\begin{split}
& M_1^{*} =  M_1, (M_1 \partial_{t}) ^{*} = -M_1^{*} \partial_{t} = -M_1 \partial_{t}, M_2^{*} =  M_2\\
& D^{*} = (D_i \partial_{i})^{*} = -D_i^{*} \partial_{i} = D_i \partial_{i} = D \Rightarrow Q^{*} = Q\\
 \end{split}
\end{equation}
which is derived from the initial, final condition and boundary condition \ref{eqn:initialCondition1} and \ref{eqn:initialCondition2} \citep{yang2016review}.\\
\par Derivative with respect to wavefields $\mathbf{u}$:
\begin{equation}
 \pdv{L_1}{\mathbf{u}} = \int_0^T \int_\Omega \left((R\mathbf{u} - \mathbf{d}^{obs})R -M_1 \partial_{t} \mathbf{u}_{1}  + M_2 \mathbf{u}_{1} - Q \mathbf{u}_{1}\right)^{*}  dt dx
\end{equation}
To satisfy the final condition of $\mathbf{u}_{1}$ (equation \ref{eqn:initialCondition2}), the time needs to be reversed by substituting $t^{'}=T-t$ ($\partial_{t^{'}} = -\partial_{t}$ and $dt^{'}=-dt$) in the above equation. Thus we get
\begin{equation}
 \pdv{L_1}{\mathbf{u}} = -\int_T^0 \int_\Omega \left( R^{*}(R\mathbf{u} - \mathbf{d}^{obs}) + M_1 \partial_{t^{'}} \mathbf{u}_{1} + M_2 \mathbf{u}_{1} - Q \mathbf{u}_{1} \right)^{*} dt^{'} dx
\end{equation}
\par By making $\pdv{L_1}{\mathbf{u}} = 0$, we obtain a self-adjoint equation:
\begin{equation}
\begin{aligned}
\label{eqn:AdjointEquation1}
 &M_1 \partial_{t^{'}} \mathbf{u}_{1}  + M_2 \mathbf{u}_{1} - Q \mathbf{u}_{1} = - R^{*}(R\mathbf{u} - \mathbf{d}^{obs})\\
& \mathbf{u}_{1} = ( \mathbf{H}_{1}, \mathbf{E}_{1}) = (H_{1x}, H_{1y}, H_{1z}, E_{1x}, E_{1y}, E_{1z})^T 
\end{aligned}
\end{equation}
\par Here the wavefield residual $R^{*}(R\mathbf{u} - \mathbf{d}^{obs}) $ is used as the sources for back propagation. \\
\par The 1st order adjoint equation is:
\begin{equation}
\label{eqn:AdjointEquation11}
\mathbf{u}_{1}:
\begin{cases}
-\mu_{m} \pdv{\mathbf{H}_{1}}{t^{'}} - \sigma_{m}\mathbf{H}_{1} - \nabla \times\mathbf{E}_{1} =  -R^{*}(R\mathbf{H} - \mathbf{H}^{obs}) \\
\varepsilon\pdv{\mathbf{E}_{1}}{t^{'}} + \sigma\mathbf{E}_{1} -\nabla \times \mathbf{H}_{1} =  - R^{*}(R\mathbf{E} - \mathbf{E}^{obs})
\end{cases}
\end{equation}
\par Derivative with respect to model parameters $\mathbf{m}$ from Eq. \ref{eqn:AugmentFunctional1}:
\begin{equation}
 \nabla \Phi_1(\mathbf{m})=\pdv{\Phi_1}{\mathbf{m}} = \pdv{L_1}{\mathbf{u}}\pdv{\mathbf{u}}{\mathbf{m}} + \pdv{L_1}{\mathbf{m}} =  \pdv{L_1}{\mathbf{m}} = \int_0^T \mathbf{u}_{1}^{*} (\pdv{M_{1}}{\mathbf{m}} \partial_{t}\mathbf{u} + \pdv{M_{2}}{\mathbf{m}} \mathbf{u} ) dt\\ 
\end{equation}
\par The gradient of the objective function $\Phi_1(\mathbf{m})$ with respect to electric parameters are shown as:
\begin{equation}
\label{eqn:GradientAdjoint1}
\begin{aligned}
& \nabla \Phi_1(\varepsilon) = \int_0^T ( E_{1x} \pdv{E_x}{t} + E_{1y} \pdv{E_y}{t} + E_{1z} \pdv{E_z}{t} ) dt\\
& \nabla \Phi_1(\sigma) = \int_0^T ( E_{1x} E_x + E_{1y} E_y + E_{1z} E_z  ) dt\\
\end{aligned}
\end{equation}

\chapter{Visco-EM wave}
\label{sec:Visco_EM_wave_equation}
For more details about Visco-EM FWI, the readers are recommended to \cite{qin2022full}.
\end{document}
